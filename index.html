<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>JaseMaster — Yellow Console</title>
  <style>
    :root{
      --bgA:#f6f6f3;
      --bgB:#ecece6;
      --panel:#e9e9e3;
      --panel2:#deded6;
      --text:#161616;
      --muted:#5b5b5b;

      --accent:#FFD400; /* Wu-Tang Yellow */
      --accent2:#f1c600;

      --shadow: 0 18px 45px rgba(0,0,0,.18);
      --shadow2: 0 10px 24px rgba(0,0,0,.12);
      --inset: inset 0 1px 0 rgba(255,255,255,.75), inset 0 -1px 0 rgba(0,0,0,.08);

      --border: rgba(0,0,0,.14);
      --meterBg:#111;
      --meterGlass: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,0));
      --radius: 18px;
      --ok:#0d7a32;
      --warn:#a06a00;
      --bad:#b00020;
    }

    body[data-theme="dark"]{
      --bgA:#0f1012;
      --bgB:#0b0c0e;
      --panel:#1a1b1f;
      --panel2:#141519;
      --text:#f3f3f3;
      --muted:#b2b2b2;
      --border: rgba(255,255,255,.10);
      --shadow: 0 18px 45px rgba(0,0,0,.55);
      --shadow2: 0 10px 24px rgba(0,0,0,.45);
      --inset: inset 0 1px 0 rgba(255,255,255,.06), inset 0 -1px 0 rgba(0,0,0,.35);
      --meterBg:#0b0b0c;
      --meterGlass: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,0));
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(1200px 650px at 50% 0%, rgba(255,212,0,.20), rgba(255,212,0,0)),
        linear-gradient(180deg, var(--bgA), var(--bgB));
      padding:16px;
    }

    .shell{
      max-width: 1280px;
      margin: 0 auto;
      border-radius: 16px;
      background: var(--panel);
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    header{
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background:
        radial-gradient(800px 220px at 50% 0%, rgba(255,212,0,.30), rgba(255,212,0,0)),
        linear-gradient(180deg, rgba(255,255,255,.30), rgba(255,255,255,0));
      border-bottom:1px solid var(--border);
    }

    .brand{display:flex;flex-direction:column;gap:4px;}
    .brandTop{display:flex;gap:10px;align-items:baseline;flex-wrap:wrap;}
    .analog{
      font-weight:1000;
      letter-spacing:.6px;
      text-transform:lowercase;
      opacity:.9;
    }
    .title{
      font-weight:1000;
      font-size:26px;
      letter-spacing:.6px;
    }
    .sub{
      font-size:12px;
      font-weight:850;
      color:var(--muted);
    }

    .topActions{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .pill{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      font-size:12px;
      font-weight:950;
      white-space:nowrap;
    }

    .btn{
      appearance:none;
      border-radius: 12px;
      padding:10px 12px;
      background: rgba(255,255,255,.12);
      border:1px solid var(--border);
      box-shadow: var(--inset);
      font-weight:950;
      color:var(--text);
      cursor:pointer;
      user-select:none;
    }
    .btn.primary{
      background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 55%, #fff 45%), var(--accent2));
      border-color: color-mix(in srgb, var(--accent2) 70%, #000 30%);
    }
    .btn:disabled{opacity:.55;cursor:not-allowed}

    .toggle{
      display:flex;gap:8px;align-items:center;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      font-weight:900;
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }
    .toggle input{transform:scale(1.15);}

    /* Layout */
    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      padding:14px 14px 16px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr;}
    }

    .card{
      background: var(--panel2);
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--inset);
      overflow:hidden;
    }
    .hd{
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,0));
    }
    .hd h2{
      margin:0;
      font-size:12px;
      letter-spacing:.9px;
      text-transform:uppercase;
    }
    .meta{
      font-size:12px;
      font-weight:950;
      color:var(--muted);
      white-space:nowrap;
    }
    .bd{padding:12px 14px;}
    .divider{height:1px;background: var(--border);opacity:.8;margin:12px 0;}
    .small{font-size:12px;font-weight:900;color:var(--muted);line-height:1.35;}

    /* Help tooltip */
    .q{
      display:inline-grid;place-items:center;
      width:18px;height:18px;border-radius:50%;
      background: var(--accent2);
      border:1px solid rgba(0,0,0,.22);
      font-weight:1000;
      font-size:12px;
      cursor:pointer;
      user-select:none;
      color:#111;
      margin-left:6px;
    }
    .q.hidden{display:none}

    .tip{
      position:fixed;z-index:1000;
      max-width:360px;
      padding:10px 12px;
      border-radius:12px;
      background: color-mix(in srgb, var(--panel) 92%, #000 8%);
      border:1px solid var(--border);
      box-shadow: var(--shadow2);
      color:var(--text);
      font-size:12px;
      font-weight:850;
      line-height:1.35;
      display:none;
      white-space:pre-wrap;
    }

    /* Audio players + spectra */
    .playerBlock{
      border:1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    audio{width:100%;}
    .specBox{
      width:100%;
      height:90px;
      border-radius: 10px;
      background: var(--meterBg);
      border:1px solid rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.30);
      overflow:hidden;
      position:relative;
    }
    .specBox::after{
      content:"";
      position:absolute;inset:0;
      background: var(--meterGlass);
      pointer-events:none;
    }
    canvas{display:block;width:100%;height:100%;}
    .kpi{
      display:flex;gap:10px;flex-wrap:wrap;
    }
    .kpi span{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      font-weight:950;
      font-size:12px;
      color: var(--muted);
    }

    .warnBox{
      display:none;
      padding:10px 12px;border-radius: 12px;
      border:1px solid var(--border);
      background: color-mix(in srgb, var(--accent) 35%, rgba(255,255,255,.10));
      font-weight:950;font-size:12px;
    }
    pre.report{
      margin:0;
      padding:12px;
      border-radius: 12px;
      background: rgba(0,0,0,.08);
      border:1px solid var(--border);
      font-size:12px;
      font-weight:850;
      line-height:1.35;
      white-space:pre-wrap;
      overflow:auto;
    }

    /* One-click styles */
    .styles{display:flex;gap:10px;flex-wrap:wrap;}
    .chip{
      border-radius:999px;
      padding:10px 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      font-weight:1000;
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .chip.active{
      outline: 2px solid color-mix(in srgb, var(--accent) 50%, transparent);
      background: linear-gradient(180deg, rgba(255,255,255,.30), rgba(255,255,255,.10));
    }

    /* Console sliders */
    .sliderGrid{
      display:grid;
      grid-template-columns: repeat(4, minmax(140px, 1fr));
      gap:12px;
    }
    @media (max-width: 980px){
      .sliderGrid{grid-template-columns: repeat(2, minmax(140px, 1fr));}
    }
    .sCard{
      border:1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      padding:10px;
    }
    .sTop{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;}
    .sTop b{font-size:12px;letter-spacing:.4px;text-transform:lowercase;}
    .sVal{font-size:12px;font-weight:1000;color:var(--muted);}
    input[type=range]{width:100%}

    /* Digital Mixing Desk (always visible) */
    .deskWrap{
      border:1px solid var(--border);
      border-radius: 16px;
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      padding:12px;
    }
    .deskHeader{
      display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;
      margin-bottom:10px;
    }
    .deskHeader b{font-size:12px;letter-spacing:.9px;text-transform:uppercase;}
    .deskNote{font-size:12px;font-weight:900;color:var(--muted);}

    .desk{
      display:grid;
      grid-template-columns: repeat(12, minmax(70px, 1fr));
      gap:10px;
      overflow-x:auto;
      padding-bottom:6px;
    }
    @media (max-width: 980px){
      .desk{grid-template-columns: repeat(6, minmax(70px, 1fr));}
    }

    .chan{
      border:1px solid var(--border);
      border-radius: 14px;
      background: rgba(255,255,255,.10);
      box-shadow: var(--inset);
      padding:10px 8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:70px;
    }
    .chan.disabled{opacity:.55}
    .chanTitle{
      font-size:11px;
      font-weight:1000;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .miniSpec{
      height:44px;
      border-radius: 10px;
      background: var(--meterBg);
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.06);
    }
    .miniSpec::after{
      content:"";
      position:absolute;inset:0;
      background: var(--meterGlass);
      pointer-events:none;
    }

    /* “fader strip” */
    .faderArea{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:stretch;
    }
    .faderLabel{
      font-size:11px;font-weight:950;color:var(--muted);
      display:flex;justify-content:space-between;gap:6px;
    }
    .vFader{
      height:190px;
      width:100%;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
    }
    .pan{
      width:100%;
    }
    .btnRow{display:flex;gap:6px;flex-wrap:wrap;justify-content:space-between;}
    .miniBtn{
      padding:7px 9px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.12);
      box-shadow: var(--inset);
      font-weight:1000;
      font-size:11px;
      cursor:pointer;
      user-select:none;
      width:100%;
      text-align:center;
    }
    .miniBtn.on{
      background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 45%, #fff 55%), var(--accent2));
      color:#111;
    }
  </style>
</head>

<body data-theme="light">
  <div class="shell">
    <header>
      <div class="brand">
        <div class="brandTop">
          <div class="analog">analog obsession</div>
          <div class="title">JaseMaster</div>
        </div>
        <div class="sub">Yellow Console Edition • Stereo or 2–12 stems • A/B level-match • per-player spectrum</div>
      </div>

      <div class="topActions">
        <label class="toggle" data-tip="Show/hide little help popups. Click the yellow “?” for quick explanations.">
          <input id="helpToggle" type="checkbox" checked> Help
        </label>
        <button class="btn" id="themeBtn" data-tip="Toggle Light/Dark.">Dark</button>
        <div class="pill" id="statusPill">Load audio to begin</div>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <div class="hd">
          <h2>Players</h2>
          <div class="meta" id="modeMeta">Mode: —</div>
        </div>

        <div class="bd">
          <div class="small">
            <b>Upload</b>
            <span class="q" data-tip="1 file = Stereo mode.\n2–12 files = Stem mode (mixer becomes active).\nTip: for stems use PCM WAV, same length + sample rate.">?</span>
          </div>
          <input id="fileInput" type="file" accept="audio/*" multiple />
          <div class="warnBox" id="decodeWarn"></div>

          <div class="divider"></div>

          <div class="small"><b>Original</b><span class="q" data-tip="Dry mix (stereo) or the current stem sum (if stems).">?</span></div>
          <div class="playerBlock">
            <audio id="audioOriginal" controls></audio>
            <div class="specBox"><canvas id="specOriginal"></canvas></div>
            <div class="kpi" id="kpiOriginal"></div>
          </div>

          <div class="divider"></div>

          <div class="small"><b>Mastered</b><span class="q" data-tip="After Auto-Master, this will fill with the mastered WAV.">?</span></div>
          <div class="playerBlock">
            <audio id="audioMastered" controls></audio>
            <div class="specBox"><canvas id="specMastered"></canvas></div>
            <div class="kpi" id="kpiMastered"></div>
          </div>

          <div class="divider"></div>

          <div class="small"><b>Reference (optional)</b><span class="q" data-tip="Load a pro track.\nMatch Tone will nudge settings safely.">?</span></div>
          <input id="refInput" type="file" accept="audio/*"/>
          <div class="playerBlock">
            <audio id="audioReference" controls></audio>
            <div class="specBox"><canvas id="specReference"></canvas></div>
            <div class="kpi" id="kpiReference"></div>
          </div>

          <div class="divider"></div>

          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;">
            <label class="toggle" data-tip="Matches loudness so you compare tone, not volume.">
              <input id="abMatch" type="checkbox" checked> Level-match A/B
            </label>
            <button class="btn" id="abSwapBtn" disabled data-tip="Instantly switch between Original and Mastered at the same time position.">A/B Swap</button>
          </div>

          <div class="divider"></div>

          <div class="small"><b>Mastering Report</b><span class="q" data-tip="Shows before/after stats and what was changed.">?</span></div>
          <pre class="report" id="reportBox">No master yet.</pre>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="hd">
          <h2>Console</h2>
          <div class="meta" id="engineMeta">Engine: —</div>
        </div>

        <div class="bd">
          <div class="small"><b>One-Click Styles</b><span class="q" data-tip="Pick a vibe → Auto-Master.\nIf it gets louder but worse, lower Intensity.">?</span></div>
          <div class="styles" id="styleBar">
            <div class="chip active" data-style="upbeat" data-tip="Clean vocal sparkle + punchy drums (safe).">Upbeat Worship</div>
            <div class="chip" data-style="pop" data-tip="Brighter & tighter (radio-ish).">Pop Punch</div>
            <div class="chip" data-style="rock" data-tip="More mid bite, less top shine.">Rock Edge</div>
            <div class="chip" data-style="lofi" data-tip="Warm + softened highs.">Lo-Fi Warm</div>
            <div class="chip" data-style="club" data-tip="Hotter (more risk of crunch).">Club Hot</div>
          </div>

          <div class="divider"></div>

          <div class="small"><b>Master Controls (mixing-desk sliders)</b><span class="q" data-tip="Target = loudness goal.\nCeiling = max peak.\nIntensity = how hard it pushes.\nWidth = widen high frequencies.">?</span></div>

          <div class="sliderGrid">
            <div class="sCard">
              <div class="sTop">
                <b>Target</b>
                <span class="sVal" id="targetVal">-14 LUFS-ish</span>
              </div>
              <select id="targetPreset" style="width:100%;padding:10px;border-radius:12px;border:1px solid var(--border);background:rgba(255,255,255,.12);box-shadow:var(--inset);font-weight:950;">
                <option value="-14">Streaming (-14)</option>
                <option value="-11">Hot (-11)</option>
                <option value="-9">Club (-9)</option>
              </select>
            </div>

            <div class="sCard">
              <div class="sTop">
                <b>Ceiling</b>
                <span class="sVal" id="ceilingVal">-1.0 dB</span>
              </div>
              <input id="ceiling" type="range" min="-2.0" max="0.0" step="0.1" value="-1.0">
            </div>

            <div class="sCard">
              <div class="sTop">
                <b>Intensity</b>
                <span class="sVal" id="intensityVal">35%</span>
              </div>
              <input id="intensity" type="range" min="0" max="100" step="1" value="35">
            </div>

            <div class="sCard">
              <div class="sTop">
                <b>Width</b>
                <span class="sVal" id="widthVal">1.10×</span>
              </div>
              <input id="width" type="range" min="1.00" max="1.35" step="0.01" value="1.10">
            </div>
          </div>

          <div class="divider"></div>

          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <label class="toggle" data-tip="Removes low rumble below ~30 Hz."><input id="hpf" type="checkbox" checked> Rumble</label>
            <label class="toggle" data-tip="Gently reduces 250–350 Hz mud."><input id="mud" type="checkbox" checked> Mud</label>
            <label class="toggle" data-tip="Tames harsh 2–5 kHz."><input id="deharsh" type="checkbox" checked> Harsh</label>
            <label class="toggle" data-tip="Adds ‘air’ above 10 kHz."><input id="air" type="checkbox" checked> Air</label>
            <label class="toggle" data-tip="Adds gentle thickness."><input id="warmth" type="checkbox" checked> Warmth</label>
            <label class="toggle" data-tip="Mono the low end (club safe)."><input id="monoBass" type="checkbox" checked> Mono Bass</label>
            <label class="toggle" data-tip="Light compression glue."><input id="glue" type="checkbox" checked> Glue</label>
            <label class="toggle" data-tip="Parallel punch."><input id="parallel" type="checkbox" checked> Parallel</label>
          </div>

          <div class="divider"></div>

          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;">
            <button class="btn primary" id="autoBtn" disabled data-tip="Renders a mastered WAV and generates a report.">Auto-Master</button>
            <button class="btn" id="matchToneBtn" disabled data-tip="Uses your reference to nudge EQ/intensity safely.">Match Tone</button>
            <button class="btn" id="exportBtn" disabled data-tip="Download mastered WAV (PCM 16-bit).">Export WAV</button>
          </div>

          <div class="divider"></div>

          <div class="deskWrap">
            <div class="deskHeader">
              <b>Stem Mixer (Digital Desk)</b>
              <div class="deskNote" id="deskNote">Always visible • Upload 2–12 stems to enable</div>
            </div>
            <div class="desk" id="desk"></div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <div class="tip" id="tipBox"></div>

<script>
/* =========================
   Helpers
========================= */
const $ = id => document.getElementById(id);
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const dbToGain=db=>Math.pow(10,db/20);
const gainToDb=g=>20*Math.log10(Math.max(1e-12,g));
const fmtTime=(sec)=>{ sec=Math.max(0,Math.floor(sec||0)); const m=String(Math.floor(sec/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); return `${m}:${s}`; };

function setStatus(msg, kind="ok"){
  const el=$("statusPill");
  el.textContent=msg;
  el.style.color = kind==="ok" ? "var(--ok)" : kind==="warn" ? "var(--warn)" : "var(--bad)";
}

/* =========================
   Help tips
========================= */
let helpOn=true;
const tipBox=$("tipBox");
function showTip(el, text){
  if(!helpOn || !text) return;
  tipBox.textContent=text;
  tipBox.style.display="block";
  const r=el.getBoundingClientRect();
  const pad=10;
  let x=r.left + r.width/2 - tipBox.offsetWidth/2;
  let y=r.bottom + 10;
  x=clamp(x, pad, window.innerWidth - tipBox.offsetWidth - pad);
  if(y + tipBox.offsetHeight > window.innerHeight - pad) y=r.top - tipBox.offsetHeight - 10;
  tipBox.style.left=`${x}px`;
  tipBox.style.top=`${y}px`;
}
function hideTip(){ tipBox.style.display="none"; }

function wireTips(){
  document.querySelectorAll("[data-tip]").forEach(el=>{
    el.addEventListener("mouseenter",()=>showTip(el, el.getAttribute("data-tip")));
    el.addEventListener("mouseleave",hideTip);
  });
  document.querySelectorAll(".q").forEach(q=>{
    q.addEventListener("click",(e)=>{
      e.stopPropagation();
      showTip(q, q.getAttribute("data-tip"));
      setTimeout(hideTip, 3200);
    });
  });
  document.addEventListener("click", hideTip);
}
wireTips();

$("helpToggle").addEventListener("change",(e)=>{
  helpOn=e.target.checked;
  document.querySelectorAll(".q").forEach(q=>q.classList.toggle("hidden", !helpOn));
  if(!helpOn) hideTip();
});

$("themeBtn").addEventListener("click", ()=>{
  const b=document.body;
  const isLight=b.getAttribute("data-theme")!=="dark";
  b.setAttribute("data-theme", isLight?"dark":"light");
  $("themeBtn").textContent = isLight ? "Light":"Dark";
});

/* =========================
   Audio state
========================= */
const state={
  ctx:null,
  mode:"none",
  engine:"—",
  style:"upbeat",
  buffers:[],
  stemSettings:[],
  sumDryBuffer:null,
  masterBuffer:null,
  refBuffer:null,
  masteredBlob:null,
  analysis:{orig:null,mast:null,ref:null},
  urls:{orig:null,mast:null},
  media:{orig:null,mast:null,ref:null},
  specRAF:{orig:0,mast:0,ref:0},
  stemThumbs:[] // static FFT thumbnails for each stem
};

function ensureCtx(){
  if(!state.ctx) state.ctx = new (window.AudioContext||window.webkitAudioContext)();
  return state.ctx;
}
async function decodeFile(file){
  const ctx=ensureCtx();
  if(ctx.state==="suspended") await ctx.resume().catch(()=>{});
  const arr=await file.arrayBuffer();
  return await ctx.decodeAudioData(arr.slice(0));
}
function revoke(url){ try{ if(url) URL.revokeObjectURL(url); }catch(e){} }

/* =========================
   Analysis / KPI
========================= */
function analyzeBuffer(buf){
  const ch0=buf.getChannelData(0);
  const ch1=buf.numberOfChannels>1 ? buf.getChannelData(1) : null;
  let peak=0, sumSq=0;
  const n=ch0.length;
  for(let i=0;i<n;i++){
    const v = ch1 ? 0.5*(ch0[i]+ch1[i]) : ch0[i];
    const a=Math.abs(v);
    if(a>peak) peak=a;
    sumSq += v*v;
  }
  const rms=Math.sqrt(sumSq/n);
  const peakDbfs = gainToDb(Math.min(peak,1.0));
  const over = peak > 1.00001;
  const rmsDb=gainToDb(rms);
  return {ch:buf.numberOfChannels,sr:buf.sampleRate,dur:buf.duration,peak,over,peakDbfs,rmsDb,lufsIsh:rmsDb};
}
function setKpi(which, info){
  const el = which==="orig"?$("kpiOriginal"):which==="mast"?$("kpiMastered"):$("kpiReference");
  if(!info){ el.innerHTML=""; return; }
  el.innerHTML = `
    <span>${info.ch}ch</span>
    <span>${Math.round(info.sr/1000)} kHz</span>
    <span>${fmtTime(info.dur)}</span>
    <span>Peak ${info.peakDbfs.toFixed(1)} dBFS${info.over?" • OVER":""}</span>
    <span>RMS ${info.rmsDb.toFixed(1)} dB</span>
    <span>LUFS-ish ${info.lufsIsh.toFixed(1)}</span>
  `;
}

/* =========================
   WAV encode (PCM 16-bit)
========================= */
function encodeWav16(buffer){
  const numCh=buffer.numberOfChannels;
  const sr=buffer.sampleRate;
  const n=buffer.length;
  const bits=16;
  const blockAlign=numCh*(bits/8);
  const byteRate=sr*blockAlign;
  const dataSize=n*blockAlign;
  const ab=new ArrayBuffer(44+dataSize);
  const view=new DataView(ab);
  let o=0;
  const wstr=s=>{ for(let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); };
  const u32=v=>{ view.setUint32(o,v,true); o+=4; };
  const u16=v=>{ view.setUint16(o,v,true); o+=2; };

  wstr("RIFF"); u32(36+dataSize); wstr("WAVE");
  wstr("fmt "); u32(16);
  u16(1); u16(numCh);
  u32(sr); u32(byteRate);
  u16(blockAlign); u16(bits);
  wstr("data"); u32(dataSize);

  const chans=[];
  for(let c=0;c<numCh;c++) chans.push(buffer.getChannelData(c));
  for(let i=0;i<n;i++){
    for(let c=0;c<numCh;c++){
      const x=clamp(chans[c][i],-1,1);
      view.setInt16(o, x<0? x*0x8000 : x*0x7FFF, true);
      o+=2;
    }
  }
  return new Uint8Array(ab);
}

/* =========================
   UI bindings
========================= */
function setMode(mode){
  state.mode=mode;
  $("modeMeta").textContent = `Mode: ${mode==="stems"?"Stems (Desk)":mode==="stereo"?"Stereo":"—"}`;
  $("engineMeta").textContent = `Engine: ${state.engine}`;
  $("deskNote").textContent = mode==="stems"
    ? "Enabled • Move faders to rebalance stems"
    : "Always visible • Upload 2–12 stems to enable";
}
function bindRange(id,out,fmt){
  const r=$(id), o=$(out);
  const f=()=>o.textContent=fmt(r.value);
  r.addEventListener("input",f); f();
}
bindRange("ceiling","ceilingVal",v=>`${Number(v).toFixed(1)} dB`);
bindRange("intensity","intensityVal",v=>`${v|0}%`);
bindRange("width","widthVal",v=>`${Number(v).toFixed(2)}×`);
$("targetPreset").addEventListener("change",()=> $("targetVal").textContent = `${$("targetPreset").value} LUFS-ish`);

$("styleBar").addEventListener("click",(e)=>{
  const chip=e.target.closest(".chip");
  if(!chip) return;
  document.querySelectorAll(".chip").forEach(x=>x.classList.remove("active"));
  chip.classList.add("active");
  state.style=chip.dataset.style;

  if(state.style==="upbeat"){ $("targetPreset").value="-14"; $("intensity").value="35"; $("width").value="1.10"; }
  if(state.style==="pop"){ $("targetPreset").value="-11"; $("intensity").value="42"; $("width").value="1.14"; }
  if(state.style==="rock"){ $("targetPreset").value="-11"; $("intensity").value="40"; $("width").value="1.08"; $("air").checked=false; }
  if(state.style==="lofi"){ $("targetPreset").value="-14"; $("intensity").value="28"; $("width").value="1.05"; $("air").checked=false; $("warmth").checked=true; }
  if(state.style==="club"){ $("targetPreset").value="-9"; $("intensity").value="48"; $("width").value="1.12"; }

  $("targetVal").textContent = `${$("targetPreset").value} LUFS-ish`;
  $("intensityVal").textContent = `${$("intensity").value|0}%`;
  $("widthVal").textContent = `${Number($("width").value).toFixed(2)}×`;
});

/* =========================
   Read settings
========================= */
function readSettings(){
  const style=state.style;
  const tweak=({upbeat:1.0,pop:1.05,rock:1.0,lofi:0.9,club:1.1}[style]||1.0);
  return {
    style,
    target: clamp(Number($("targetPreset").value)*tweak, -14, -9),
    ceiling: Number($("ceiling").value),
    intensity: Number($("intensity").value)/100,
    width: Number($("width").value),
    hpf:$("hpf").checked,
    mud:$("mud").checked,
    deharsh:$("deharsh").checked,
    air:$("air").checked,
    warmth:$("warmth").checked,
    monoBass:$("monoBass").checked,
    glue:$("glue").checked,
    parallel:$("parallel").checked
  };
}

/* =========================
   Static FFT thumbnail (for stem channels)
   - quick average spectrum from a short segment
========================= */
async function makeSpectrumThumbnail(buffer, canvas){
  const sr=buffer.sampleRate;
  const segSec=Math.min(6, buffer.duration);
  const segLen=Math.max(1, Math.floor(segSec*sr));
  const start=Math.max(0, Math.floor((buffer.length-segLen)*0.45));

  // mono segment
  const mono=new Float32Array(segLen);
  const ch0=buffer.getChannelData(0);
  const ch1=buffer.numberOfChannels>1 ? buffer.getChannelData(1) : null;
  for(let i=0;i<segLen;i++){
    const v = ch1 ? 0.5*(ch0[start+i]+ch1[start+i]) : ch0[start+i];
    mono[i]=v;
  }

  // simple FFT-ish bars via browser Analyser in OfflineAudioContext
  const off=new OfflineAudioContext(1, segLen, sr);
  const src=off.createBufferSource();
  const buf=new AudioBuffer({length:segLen,numberOfChannels:1,sampleRate:sr});
  buf.getChannelData(0).set(mono);
  src.buffer=buf;

  const analyser=off.createAnalyser();
  analyser.fftSize=2048;
  src.connect(analyser);
  analyser.connect(off.destination);

  const fd=new Uint8Array(analyser.frequencyBinCount);
  src.start(0);

  // render (we don't need output, just to advance)
  await off.startRendering();

  analyser.getByteFrequencyData(fd);

  drawBars(canvas, fd);
}

function fitCanvas(c){
  const r=c.getBoundingClientRect();
  c.width=Math.max(2, Math.floor(r.width*devicePixelRatio));
  c.height=Math.max(2, Math.floor(r.height*devicePixelRatio));
}
function drawBars(canvas, fd){
  fitCanvas(canvas);
  const ctx=canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const bins=32;
  const step=Math.floor(fd.length/bins);
  for(let b=0;b<bins;b++){
    let sum=0;
    for(let i=0;i<step;i++) sum += fd[b*step+i]||0;
    const v=(sum/(step*255));
    const x0=(b/bins)*canvas.width;
    const x1=((b+1)/bins)*canvas.width;
    const w=Math.max(1, x1-x0-1*devicePixelRatio);
    const h=v*canvas.height;
    ctx.fillStyle="rgba(255,255,255,0.70)";
    ctx.fillRect(x0, canvas.height-h, w, h);
  }
}

/* =========================
   Digital desk (always visible 12 channels)
========================= */
function initDesk(){
  const desk=$("desk");
  desk.innerHTML="";
  for(let i=0;i<12;i++){
    const chan=document.createElement("div");
    chan.className="chan disabled";
    chan.dataset.idx=String(i);
    chan.innerHTML=`
      <div class="chanTitle">—</div>
      <div class="miniSpec"><canvas></canvas></div>

      <div class="faderArea">
        <div class="faderLabel"><span>gain</span><span class="gVal">—</span></div>
        <input class="vFader" type="range" min="-36" max="6" step="0.1" value="0" disabled>
        <div class="faderLabel"><span>pan</span><span class="pVal">—</span></div>
        <input class="pan" type="range" min="-1" max="1" step="0.01" value="0" disabled>
        <div class="btnRow">
          <button class="miniBtn" disabled>Mute</button>
        </div>
      </div>
    `;
    desk.appendChild(chan);
  }
}
initDesk();

function updateDeskFromState(){
  const desk=$("desk");
  const channels=[...desk.querySelectorAll(".chan")];

  const enabled = (state.mode==="stems" && state.stemSettings.length>=2);
  channels.forEach((ch,i)=>{
    const s=state.stemSettings[i] || null;
    const title=ch.querySelector(".chanTitle");
    const cSpec=ch.querySelector("canvas");
    const fader=ch.querySelector(".vFader");
    const pan=ch.querySelector(".pan");
    const muteBtn=ch.querySelector(".miniBtn");
    const gVal=ch.querySelector(".gVal");
    const pVal=ch.querySelector(".pVal");

    if(s){
      title.textContent = `${i+1} ${s.name}`;
      ch.classList.toggle("disabled", !enabled);
      fader.disabled = !enabled;
      pan.disabled = !enabled;
      muteBtn.disabled = !enabled;

      fader.value = s.gainDb;
      pan.value = s.pan;
      gVal.textContent = `${Number(s.gainDb).toFixed(1)} dB`;
      pVal.textContent = `${Number(s.pan).toFixed(2)}`;

      muteBtn.textContent = s.mute ? "Muted" : "Mute";
      muteBtn.classList.toggle("on", !!s.mute);

      // spectrum thumb
      if(state.stemThumbs[i]) drawBars(cSpec, state.stemThumbs[i]);
      else {
        // blank
        fitCanvas(cSpec);
        const ctx=cSpec.getContext("2d"); ctx.clearRect(0,0,cSpec.width,cSpec.height);
      }

      // listeners (once)
      if(!ch.dataset.wired){
        ch.dataset.wired="1";
        fader.addEventListener("input", ()=>{
          const idx=Number(ch.dataset.idx);
          const ss=state.stemSettings[idx]; if(!ss) return;
          ss.gainDb=Number(fader.value);
          gVal.textContent = `${ss.gainDb.toFixed(1)} dB`;
        });
        pan.addEventListener("input", ()=>{
          const idx=Number(ch.dataset.idx);
          const ss=state.stemSettings[idx]; if(!ss) return;
          ss.pan=Number(pan.value);
          pVal.textContent = `${ss.pan.toFixed(2)}`;
        });
        muteBtn.addEventListener("click", ()=>{
          const idx=Number(ch.dataset.idx);
          const ss=state.stemSettings[idx]; if(!ss) return;
          ss.mute=!ss.mute;
          muteBtn.textContent = ss.mute ? "Muted" : "Mute";
          muteBtn.classList.toggle("on", ss.mute);
        });
      }
    } else {
      title.textContent = "—";
      ch.classList.add("disabled");
      fader.disabled=true; pan.disabled=true; muteBtn.disabled=true;
      gVal.textContent="—"; pVal.textContent="—";
      muteBtn.textContent="Mute"; muteBtn.classList.remove("on");
      fitCanvas(cSpec);
      const ctx=cSpec.getContext("2d"); ctx.clearRect(0,0,cSpec.width,cSpec.height);
    }
  });
}

/* =========================
   Offline sum (stems)
========================= */
async function renderDrySumFromStems(buffers){
  const sr=buffers[0].sampleRate;
  const len=buffers[0].length;
  const off=new OfflineAudioContext(2, len, sr);
  const bus=off.createGain(); bus.gain.value=1;

  buffers.forEach((b,idx)=>{
    const src=off.createBufferSource(); src.buffer=b;
    const g=off.createGain();
    const p=off.createStereoPanner();
    const s=state.stemSettings[idx];
    g.gain.value = s.mute ? 0 : dbToGain(s.gainDb);
    p.pan.value = s.pan;
    src.connect(g).connect(p).connect(bus);
    src.start(0);
  });

  bus.connect(off.destination);
  return await off.startRendering();
}

/* =========================
   Master chain (same “safe” approach)
========================= */
function makeSaturationCurve(amount){
  const n=65536;
  const curve=new Float32Array(n);
  const k=clamp(amount,0.01,2.0)*2.2;
  const norm=Math.tanh(k);
  for(let i=0;i<n;i++){
    const x=(i/(n-1))*2-1;
    curve[i]=Math.tanh(k*x)/norm;
  }
  return curve;
}

async function offlineMasterFromBuffer(input, settings){
  const preA=analyzeBuffer(input);
  const preTargetPeakDb=-6.0;
  const preGainDb=clamp(preTargetPeakDb - preA.peakDbfs, -30, 12);

  const sr=input.sampleRate;
  const len=input.length;
  const off=new OfflineAudioContext(2, len, sr);

  let inBuf=input;
  if(input.numberOfChannels===1){
    const bb=new AudioBuffer({length:input.length, numberOfChannels:2, sampleRate:sr});
    bb.getChannelData(0).set(input.getChannelData(0));
    bb.getChannelData(1).set(input.getChannelData(0));
    inBuf=bb;
  }

  const src=off.createBufferSource(); src.buffer=inBuf;
  const pre=off.createGain(); pre.gain.value=dbToGain(preGainDb);

  const hpf=off.createBiquadFilter(); hpf.type="highpass"; hpf.frequency.value=30;
  const mud=off.createBiquadFilter(); mud.type="peaking"; mud.frequency.value=300; mud.Q.value=1;
  const harsh=off.createBiquadFilter(); harsh.type="peaking"; harsh.frequency.value=3500; harsh.Q.value=1.2;
  const air=off.createBiquadFilter(); air.type="highshelf"; air.frequency.value=12000;

  mud.gain.value   = settings.mud ? (-1.3*settings.intensity) : 0;
  harsh.gain.value = settings.deharsh ? (-1.1*settings.intensity) : 0;
  air.gain.value   = settings.air ? (0.9*settings.intensity) : 0;

  const glue=off.createDynamicsCompressor();
  glue.threshold.value=-18; glue.knee.value=20; glue.ratio.value=2.2;
  glue.attack.value=0.03; glue.release.value=0.18;

  const punch=off.createDynamicsCompressor();
  punch.threshold.value=-30; punch.knee.value=10; punch.ratio.value=8;
  punch.attack.value=0.01; punch.release.value=0.22;

  const dry=off.createGain(); dry.gain.value=1.0;
  const wet=off.createGain(); wet.gain.value = settings.parallel ? (0.08 + 0.18*settings.intensity) : 0.0;
  const sum=off.createGain();

  // M/S widen highs
  const split=off.createChannelSplitter(2);
  const merge=off.createChannelMerger(2);

  const gL=off.createGain(); gL.gain.value=0.5;
  const gR=off.createGain(); gR.gain.value=0.5;
  const gL2=off.createGain(); gL2.gain.value=0.5;
  const invR=off.createGain(); invR.gain.value=-0.5;

  const mid=off.createGain();
  const side=off.createGain();
  const sideHP=off.createBiquadFilter(); sideHP.type="highpass"; sideHP.frequency.value=120;
  const sideW=off.createGain(); sideW.gain.value=settings.width;

  const toL_mid=off.createGain(); toL_mid.gain.value=1;
  const toL_side=off.createGain(); toL_side.gain.value=1;
  const toR_mid=off.createGain(); toR_mid.gain.value=1;
  const toR_side=off.createGain(); toR_side.gain.value=-1;

  const sat=off.createWaveShaper();
  sat.curve = makeSaturationCurve(0.50 + 0.70*settings.intensity);
  sat.oversample="4x";

  src.connect(pre);
  let n=pre;
  if(settings.hpf){ n.connect(hpf); n=hpf; }
  n.connect(mud); n=mud;
  n.connect(harsh); n=harsh;
  n.connect(air); n=air;
  if(settings.glue){ n.connect(glue); n=glue; }

  n.connect(split);

  split.connect(gL,0); gL.connect(mid);
  split.connect(gR,1); gR.connect(mid);

  split.connect(gL2,0); gL2.connect(side);
  split.connect(invR,1); invR.connect(side);

  if(settings.monoBass){
    side.connect(sideHP);
    sideHP.connect(sideW);
  } else {
    side.connect(sideW);
  }

  mid.connect(toL_mid); toL_mid.connect(merge,0,0);
  sideW.connect(toL_side); toL_side.connect(merge,0,0);

  mid.connect(toR_mid); toR_mid.connect(merge,0,1);
  sideW.connect(toR_side); toR_side.connect(merge,0,1);

  merge.connect(dry);
  merge.connect(punch);
  punch.connect(wet);
  dry.connect(sum);
  wet.connect(sum);

  if(settings.warmth) sum.connect(sat).connect(off.destination);
  else sum.connect(off.destination);

  src.start(0);
  const rendered=await off.startRendering();

  const postA=analyzeBuffer(rendered);
  const makeUpDb = clamp((settings.target - postA.rmsDb) * (0.45 + 0.55*settings.intensity), -10, 8);
  const makeUp = dbToGain(makeUpDb);

  const out=new AudioBuffer({length:rendered.length, numberOfChannels:2, sampleRate:rendered.sampleRate});
  for(let c=0;c<2;c++){
    const s=rendered.getChannelData(c);
    const d=out.getChannelData(c);
    for(let i=0;i<s.length;i++) d[i]=s[i]*makeUp;
  }

  const afterMake=analyzeBuffer(out);
  const ceil = dbToGain(settings.ceiling);
  let limiterScale=1.0;
  if(afterMake.peak > ceil){
    limiterScale = ceil / afterMake.peak;
    for(let c=0;c<2;c++){
      const d=out.getChannelData(c);
      for(let i=0;i<d.length;i++) d[i]*=limiterScale;
    }
  }

  const finalA=analyzeBuffer(out);

  return {
    buffer: out,
    stats: {preA, postA, afterMake, finalA},
    moves: {
      style: settings.style,
      preGainDb, makeUpDb, limiterScale,
      width: settings.width.toFixed(2),
      monoBass: settings.monoBass ? "On (<120Hz mono)" : "Off",
      warmth: settings.warmth ? "On" : "Off",
      glue: settings.glue ? "On" : "Off",
      parallel: settings.parallel ? `On (${(0.08 + 0.18*settings.intensity).toFixed(2)} mix)` : "Off",
      eq: {
        hpf: settings.hpf ? "On @30Hz" : "Off",
        mud: settings.mud ? `-${(1.3*settings.intensity).toFixed(2)} dB @300Hz` : "Off",
        deharsh: settings.deharsh ? `-${(1.1*settings.intensity).toFixed(2)} dB @3.5kHz` : "Off",
        air: settings.air ? `+${(0.9*settings.intensity).toFixed(2)} dB @12kHz` : "Off",
      },
      target: settings.target,
      ceiling: settings.ceiling
    }
  };
}

/* =========================
   Reference match (safe)
========================= */
async function bandProfile(buffer){
  const sr=buffer.sampleRate;
  const segSec=Math.min(10, buffer.duration);
  const segLen=Math.max(1, Math.floor(segSec*sr));
  const start=Math.max(0, Math.floor((buffer.length-segLen)*0.5));

  const seg=new AudioBuffer({length:segLen, numberOfChannels:buffer.numberOfChannels, sampleRate:sr});
  for(let c=0;c<seg.numberOfChannels;c++){
    const src=buffer.getChannelData(c), dst=seg.getChannelData(c);
    for(let i=0;i<segLen;i++) dst[i]=src[start+i]||0;
  }

  const off=new OfflineAudioContext(3, segLen, sr);
  const src=off.createBufferSource(); src.buffer=seg;

  const mono=off.createGain();
  if(seg.numberOfChannels>1){
    const sp=off.createChannelSplitter(2);
    const gL=off.createGain(); gL.gain.value=0.5;
    const gR=off.createGain(); gR.gain.value=0.5;
    src.connect(sp);
    sp.connect(gL,0); sp.connect(gR,1);
    gL.connect(mono); gR.connect(mono);
  } else src.connect(mono);

  const low=off.createBiquadFilter(); low.type="lowpass"; low.frequency.value=200;
  const mid=off.createBiquadFilter(); mid.type="bandpass"; mid.frequency.value=1000; mid.Q.value=0.8;
  const high=off.createBiquadFilter(); high.type="highpass"; high.frequency.value=6000;

  const merge=off.createChannelMerger(3);
  mono.connect(low); low.connect(merge,0,0);
  mono.connect(mid); mid.connect(merge,0,1);
  mono.connect(high); high.connect(merge,0,2);

  merge.connect(off.destination);
  src.start(0);
  const r=await off.startRendering();

  const bandRmsDb=(arr)=>{
    let sum=0; for(let i=0;i<arr.length;i++) sum+=arr[i]*arr[i];
    const rms=Math.sqrt(sum/arr.length);
    return gainToDb(rms);
  };
  return {lowDb: bandRmsDb(r.getChannelData(0)), midDb: bandRmsDb(r.getChannelData(1)), highDb: bandRmsDb(r.getChannelData(2))};
}

/* =========================
   A/B match (HTML audio)
========================= */
function applyABMatch(){
  if(!$("abMatch").checked){
    $("audioOriginal").volume=1;
    $("audioMastered").volume=1;
    return;
  }
  const o=state.analysis.orig, m=state.analysis.mast;
  if(!o || !m){ $("audioOriginal").volume=1; $("audioMastered").volume=1; return; }
  const diffDb = o.rmsDb - m.rmsDb;
  $("audioOriginal").volume=1.0;
  $("audioMastered").volume=clamp(dbToGain(diffDb), 0.2, 1.0);
}
$("abMatch").addEventListener("change", applyABMatch);

$("abSwapBtn").addEventListener("click", async ()=>{
  const ao=$("audioOriginal"), am=$("audioMastered");
  if(!ao.src || !am.src) return;
  applyABMatch();
  const oPlaying=!ao.paused;
  const mPlaying=!am.paused;
  if(!oPlaying && !mPlaying){
    ao.currentTime=0; am.currentTime=0;
    await ao.play();
    return;
  }
  if(oPlaying){
    const t=ao.currentTime; ao.pause();
    am.currentTime=t; await am.play();
  } else {
    const t=am.currentTime; am.pause();
    ao.currentTime=t; await ao.play();
  }
});

/* =========================
   Real-time spectra per player (MediaElement analysers)
========================= */
function setupMediaAnalyser(which, audioEl, canvasEl){
  const ctx=ensureCtx();
  // kill old
  if(state.media[which]?.srcNode){
    try{ state.media[which].srcNode.disconnect(); }catch(e){}
  }
  const srcNode=ctx.createMediaElementSource(audioEl);
  const analyser=ctx.createAnalyser();
  analyser.fftSize=2048;
  srcNode.connect(analyser);
  analyser.connect(ctx.destination);

  state.media[which]={srcNode, analyser, canvas:canvasEl};

  const fd=new Uint8Array(analyser.frequencyBinCount);

  function draw(){
    state.specRAF[which]=requestAnimationFrame(draw);
    analyser.getByteFrequencyData(fd);
    drawBars(canvasEl, fd);
  }

  const start=()=>{ cancelAnimationFrame(state.specRAF[which]); draw(); };
  const stop=()=>{ cancelAnimationFrame(state.specRAF[which]); state.specRAF[which]=0; };

  audioEl.addEventListener("play", async ()=>{
    if(ctx.state==="suspended") await ctx.resume().catch(()=>{});
    start();
  });
  audioEl.addEventListener("pause", stop);
  audioEl.addEventListener("ended", stop);

  // initial blank
  fitCanvas(canvasEl);
  const c=canvasEl.getContext("2d"); c.clearRect(0,0,canvasEl.width,canvasEl.height);
}

setupMediaAnalyser("orig", $("audioOriginal"), $("specOriginal"));
setupMediaAnalyser("mast", $("audioMastered"), $("specMastered"));
setupMediaAnalyser("ref", $("audioReference"), $("specReference"));

/* =========================
   Report
========================= */
function buildReport(moves, stats){
  const a0=stats.preA;
  const a1=stats.finalA;
  const lines=[];
  lines.push(`MASTERING SUMMARY (${new Date().toLocaleString()})`);
  lines.push(`Mode: ${state.mode==="stems" ? "Stems (desk sum)" : "Stereo"}`);
  lines.push(`Style: ${moves.style}`);
  lines.push("");
  lines.push("BEFORE:");
  lines.push(`  Peak: ${a0.peakDbfs.toFixed(1)} dBFS${a0.over ? " (OVER)" : ""}`);
  lines.push(`  RMS:  ${a0.rmsDb.toFixed(1)} dB`);
  lines.push(`  LUFS-ish: ${a0.lufsIsh.toFixed(1)}`);
  lines.push("");
  lines.push("AFTER:");
  lines.push(`  Peak: ${a1.peakDbfs.toFixed(1)} dBFS (ceiling ${moves.ceiling.toFixed(1)} dB)`);
  lines.push(`  RMS:  ${a1.rmsDb.toFixed(1)} dB`);
  lines.push(`  LUFS-ish: ${a1.lufsIsh.toFixed(1)} (target ${moves.target.toFixed(1)})`);
  lines.push("");
  lines.push("WHAT CHANGED:");
  lines.push(`  Pre-gain (headroom): ${moves.preGainDb.toFixed(1)} dB`);
  lines.push(`  Makeup gain: ${moves.makeUpDb.toFixed(1)} dB`);
  lines.push(`  Ceiling scale: ${moves.limiterScale.toFixed(3)}×`);
  lines.push(`  Width: ${moves.width}×`);
  lines.push(`  Mono bass: ${moves.monoBass}`);
  lines.push(`  Warmth: ${moves.warmth}`);
  lines.push(`  Glue: ${moves.glue}`);
  lines.push(`  Parallel: ${moves.parallel}`);
  lines.push("  EQ:");
  lines.push(`    HPF: ${moves.eq.hpf}`);
  lines.push(`    Mud: ${moves.eq.mud}`);
  lines.push(`    De-harsh: ${moves.eq.deharsh}`);
  lines.push(`    Air: ${moves.eq.air}`);

  if(state.mode==="stems"){
    lines.push("");
    lines.push("STEM DESK (render-time):");
    state.stemSettings.forEach((s,i)=>{
      lines.push(`  ${i+1}. ${s.name} | gain ${s.gainDb.toFixed(1)} dB | pan ${s.pan.toFixed(2)} | ${s.mute?"MUTED":"on"}`);
    });
  }
  return lines.join("\n");
}

/* =========================
   Load audio (1–12)
========================= */
$("fileInput").addEventListener("change", async (e)=>{
  const files=Array.from(e.target.files||[]);
  $("decodeWarn").style.display="none";
  $("decodeWarn").textContent="";

  state.buffers=[];
  state.stemSettings=[];
  state.sumDryBuffer=null;
  state.masterBuffer=null;
  state.masteredBlob=null;
  state.analysis.orig=null;
  state.analysis.mast=null;
  state.stemThumbs=[];

  setKpi("orig", null);
  setKpi("mast", null);
  $("reportBox").textContent="No master yet.";

  revoke(state.urls.orig); revoke(state.urls.mast);
  state.urls.orig=null; state.urls.mast=null;

  $("audioOriginal").removeAttribute("src"); $("audioOriginal").load();
  $("audioMastered").removeAttribute("src"); $("audioMastered").load();

  $("autoBtn").disabled=true;
  $("exportBtn").disabled=true;
  $("abSwapBtn").disabled=true;

  if(files.length===0){
    state.engine="—";
    setMode("none");
    updateDeskFromState();
    setStatus("Load audio to begin","ok");
    return;
  }
  if(files.length>12){
    setStatus("Max 12 stems. Remove extras.","bad");
    return;
  }

  setStatus("Decoding…","warn");
  try{
    const bufs=[];
    for(const f of files) bufs.push(await decodeFile(f));
    state.buffers=bufs;

    if(files.length>1){
      const sr=bufs[0].sampleRate;
      const len=bufs[0].length;
      for(const b of bufs){
        if(b.sampleRate!==sr) throw new Error("Stems must share the same sample rate.");
        if(Math.abs(b.length-len) > Math.max(32, Math.floor(sr*0.01))) throw new Error("Stems must be the same length to stay in sync.");
      }
    }

    if(files.length===1){
      // Stereo mode
      state.engine="Offline (fast)";
      setMode("stereo");

      let b=bufs[0];
      if(b.numberOfChannels===1){
        const bb=new AudioBuffer({length:b.length, numberOfChannels:2, sampleRate:b.sampleRate});
        bb.getChannelData(0).set(b.getChannelData(0));
        bb.getChannelData(1).set(b.getChannelData(0));
        b=bb;
      }
      state.sumDryBuffer=b;
      state.analysis.orig=analyzeBuffer(state.sumDryBuffer);
      setKpi("orig", state.analysis.orig);

      const wav=encodeWav16(state.sumDryBuffer);
      const blob=new Blob([wav],{type:"audio/wav"});
      state.urls.orig=URL.createObjectURL(blob);
      $("audioOriginal").src=state.urls.orig;
      $("audioOriginal").load();

      $("autoBtn").disabled=false;

      // desk stays visible, but disabled
      updateDeskFromState();

      setStatus("Ready (Stereo).","ok");
      return;
    }

    // Stem mode
    state.engine="Offline (stems + master)";
    setMode("stems");

    state.stemSettings = files.map(f=>({name:f.name, gainDb:0.0, pan:0.0, mute:false}));

    // precompute stem thumbnails
    setStatus("Building stem thumbnails…","warn");
    for(let i=0;i<state.buffers.length;i++){
      // grab canvas from desk channel i and fill after thumb calc
      const chanCanvas = $("desk").querySelectorAll(".chan")[i].querySelector("canvas");
      const ctx=ensureCtx();
      // Build "fd" via offline analyser and store fd array for draw later:
      // We'll simply use makeSpectrumThumbnail but we want stored fd.
      // Easiest: run makeSpectrumThumbnail into a temp canvas then read back? Nah.
      // Instead: re-run analyser and keep fd.
      const b=state.buffers[i];
      const sr=b.sampleRate;
      const segSec=Math.min(6, b.duration);
      const segLen=Math.max(1, Math.floor(segSec*sr));
      const start=Math.max(0, Math.floor((b.length-segLen)*0.45));

      const mono=new Float32Array(segLen);
      const ch0=b.getChannelData(0);
      const ch1=b.numberOfChannels>1 ? b.getChannelData(1) : null;
      for(let j=0;j<segLen;j++){
        mono[j]= ch1 ? 0.5*(ch0[start+j]+ch1[start+j]) : ch0[start+j];
      }

      const off=new OfflineAudioContext(1, segLen, sr);
      const src=off.createBufferSource();
      const bb=new AudioBuffer({length:segLen,numberOfChannels:1,sampleRate:sr});
      bb.getChannelData(0).set(mono);
      src.buffer=bb;
      const analyser=off.createAnalyser(); analyser.fftSize=2048;
      src.connect(analyser); analyser.connect(off.destination);
      const fd=new Uint8Array(analyser.frequencyBinCount);
      src.start(0);
      await off.startRendering();
      analyser.getByteFrequencyData(fd);
      state.stemThumbs[i]=fd;
      drawBars(chanCanvas, fd);
    }

    setStatus("Summing stems…","warn");
    state.sumDryBuffer = await renderDrySumFromStems(state.buffers);
    state.analysis.orig=analyzeBuffer(state.sumDryBuffer);
    setKpi("orig", state.analysis.orig);

    const wav=encodeWav16(state.sumDryBuffer);
    const blob=new Blob([wav],{type:"audio/wav"});
    state.urls.orig=URL.createObjectURL(blob);
    $("audioOriginal").src=state.urls.orig;
    $("audioOriginal").load();

    $("autoBtn").disabled=false;
    updateDeskFromState();

    setStatus("Ready (Stems). Desk enabled.","ok");
  }catch(err){
    console.error(err);
    $("decodeWarn").style.display="block";
    $("decodeWarn").textContent="Decode failed. For stems: export as standard PCM WAV (16/24-bit), same sample rate + same length.";
    state.engine="—";
    setMode("none");
    updateDeskFromState();
    setStatus("Decode failed. Try PCM WAV.","bad");
  }
});

/* =========================
   Reference load
========================= */
$("refInput").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0];
  state.refBuffer=null;
  state.analysis.ref=null;
  setKpi("ref", null);
  $("matchToneBtn").disabled=true;
  $("audioReference").removeAttribute("src"); $("audioReference").load();

  if(!f) return;

  $("audioReference").src=URL.createObjectURL(f);
  $("audioReference").load();

  try{
    setStatus("Decoding reference…","warn");
    state.refBuffer=await decodeFile(f);
    state.analysis.ref=analyzeBuffer(state.refBuffer);
    setKpi("ref", state.analysis.ref);
    $("matchToneBtn").disabled = !state.sumDryBuffer;
    setStatus("Reference ready.","ok");
  }catch(err){
    console.warn(err);
    setStatus("Reference plays, but decode failed (Match Tone disabled).","warn");
  }
});

$("matchToneBtn").addEventListener("click", async ()=>{
  if(!state.refBuffer || !state.sumDryBuffer) return;
  try{
    setStatus("Matching tone…","warn");
    const t=await bandProfile(state.sumDryBuffer);
    const r=await bandProfile(state.refBuffer);

    const lowD=r.lowDb-t.lowDb, midD=r.midDb-t.midDb, highD=r.highDb-t.highDb;

    if(highD > 1.0) $("air").checked=true;
    if(highD < -1.0) $("deharsh").checked=true;
    if(midD < -0.8) $("mud").checked=true;
    if(lowD < -1.0) $("hpf").checked=true;

    let intensity=Number($("intensity").value);
    intensity += clamp(((r.midDb+r.highDb)-(t.midDb+t.highDb))*2.0, -8, 5);
    intensity=clamp(intensity, 10, 60);
    $("intensity").value=intensity;
    $("intensityVal").textContent=`${intensity|0}%`;

    setStatus("Tone matched ✅","ok");
  }catch(err){
    console.error(err);
    setStatus("Match Tone failed.","bad");
  }
});

/* =========================
   Auto-Master
========================= */
$("autoBtn").addEventListener("click", async ()=>{
  if(!state.sumDryBuffer) return;

  try{
    $("autoBtn").disabled=true;
    $("exportBtn").disabled=true;
    $("abSwapBtn").disabled=true;
    setStatus("Rendering master…","warn");

    // If stems: re-sum with current desk faders
    if(state.mode==="stems"){
      state.sumDryBuffer = await renderDrySumFromStems(state.buffers);
      state.analysis.orig=analyzeBuffer(state.sumDryBuffer);
      setKpi("orig", state.analysis.orig);

      const wav0=encodeWav16(state.sumDryBuffer);
      const blob0=new Blob([wav0],{type:"audio/wav"});
      revoke(state.urls.orig);
      state.urls.orig=URL.createObjectURL(blob0);
      $("audioOriginal").src=state.urls.orig;
      $("audioOriginal").load();
    }

    const settings=readSettings();
    const result=await offlineMasterFromBuffer(state.sumDryBuffer, settings);

    state.masterBuffer=result.buffer;
    state.analysis.mast=analyzeBuffer(state.masterBuffer);
    setKpi("mast", state.analysis.mast);

    const wav=encodeWav16(state.masterBuffer);
    const blob=new Blob([wav],{type:"audio/wav"});
    state.masteredBlob=blob;

    revoke(state.urls.mast);
    state.urls.mast=URL.createObjectURL(blob);
    $("audioMastered").src=state.urls.mast;
    $("audioMastered").load();

    $("exportBtn").disabled=false;
    $("abSwapBtn").disabled=false;
    applyABMatch();

    $("reportBox").textContent = buildReport(result.moves, result.stats);

    setStatus("Master ready ✅","ok");
  }catch(err){
    console.error(err);
    setStatus("Master failed. Lower Intensity.","bad");
  }finally{
    $("autoBtn").disabled=false;
  }
});

/* =========================
   Export
========================= */
$("exportBtn").addEventListener("click", ()=>{
  if(!state.masteredBlob) return;
  const a=document.createElement("a");
  a.href=URL.createObjectURL(state.masteredBlob);
  a.download=`JaseMaster_${state.style}_${state.mode}.wav`;
  a.click();
  setStatus("Exported WAV ✅","ok");
});

/* =========================
   Boot
========================= */
state.engine="—";
setMode("none");
updateDeskFromState();
setStatus("Load audio to begin","ok");
</script>
</body>
              </html>
