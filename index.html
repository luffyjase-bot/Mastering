<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wu Master — Auto A/B + Reference</title>

  <!-- WaveSurfer pinned -->
  <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.js"></script>

  <style>
    :root{
      --wu:#ffcc00;
      --wu2:#ffe27a;
      --ink:#0a0a0a;

      --bg:#ffffff;
      --panel:#ffffff;
      --panel2:#fffdf2;
      --line:#e7e7e7;

      --muted:#4b5563;
      --shadow: 0 12px 40px rgba(0,0,0,.10);
      --radius:18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; padding:14px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--ink);
      background:
        radial-gradient(900px 520px at 15% 0%, rgba(255,204,0,.42), transparent 60%),
        radial-gradient(900px 520px at 85% 15%, rgba(255,204,0,.22), transparent 60%),
        var(--bg);
      display:flex;
      justify-content:center;
    }
    .app{
      width:min(1150px, 100%);
      display:grid;
      grid-template-columns: 1.4fr 1fr 1fr;
      gap:14px;
    }
    .card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      overflow:hidden;
    }
    .hero{ grid-column: 1 / -1; padding:16px; }

    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .brand{ display:flex; flex-direction:column; gap:4px; }
    .title{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; font-weight:900; letter-spacing:.5px; font-size:16px; }
    .badge{
      background: var(--wu);
      color: var(--ink);
      border-radius:999px;
      padding:4px 10px;
      font-size:11px;
      font-weight:900;
      letter-spacing:1px;
      text-transform:uppercase;
      border:1px solid rgba(0,0,0,.12);
    }
    .subtitle{ color:var(--muted); font-size:12px; font-weight:700; }

    .btnbar{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn{
      border:1px solid rgba(0,0,0,.14);
      background:#fff;
      color:var(--ink);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: .4px;
      cursor:pointer;
      min-height: 44px;
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      transition: transform .12s ease, box-shadow .12s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 24px rgba(0,0,0,.10); }
    .btn:active{ transform: translateY(0); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; transform:none; }
    .btn.primary{ background:var(--wu); border-color: rgba(0,0,0,.18); }
    .btn.ghost{ background:#fff; }
    .btn.pill{ border-radius:999px; padding: 10px 14px; }

    .status{
      font-weight: 900;
      color: var(--ink);
      background: rgba(255,204,0,.22);
      border: 1px solid rgba(0,0,0,.12);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      white-space:nowrap;
    }

    .file{
      width:100%;
      border: 1px dashed rgba(0,0,0,.22);
      background: #fff;
      border-radius: 16px;
      padding: 12px;
      min-height: 44px;
      font-weight: 800;
    }

    #waveform{
      width:100%;
      height: 120px;
      background:#fff;
      border:1px solid var(--line);
      border-radius:16px;
      margin: 12px 0;
      overflow:hidden;
    }

    .sectionTitle{
      display:flex; align-items:center; justify-content:space-between;
      margin:0 0 8px 0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-weight: 900;
      color: var(--ink);
    }
    .hint{ color:var(--muted); font-weight: 800; font-size: 11px; }

    .select{
      padding: 11px 12px;
      border-radius: 14px;
      border:1px solid rgba(0,0,0,.14);
      background:#fff;
      font-weight: 900;
      color: var(--ink);
      width: 100%;
      min-height: 44px;
      box-shadow: 0 6px 18px rgba(0,0,0,.05);
    }

    .toggleLine{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      font-size: 12px; color: var(--muted); font-weight: 900;
    }
    .toggle{
      display:flex; gap:8px; align-items:center; user-select:none;
      border:1px solid rgba(0,0,0,.12);
      padding: 10px 12px;
      border-radius: 14px;
      background:#fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.05);
    }
    .toggle input{ width:18px; height:18px; accent-color: var(--wu); }

    .sliderLine{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin: 10px 0;
    }
    .sliderLine label{ font-size:12px; color:var(--muted); font-weight: 900; }
    input[type="range"]{ width: 240px; min-height:44px; accent-color: var(--wu); }

    .meterGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top: 10px;
    }
    .meter{
      background:#fff;
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
    }
    .meter header{
      display:flex; justify-content:space-between; align-items:center;
      font-size: 11px; font-weight: 900;
      letter-spacing: .6px;
      color: var(--ink);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    canvas{ width:100%; height:68px; display:block; }

    .bigAuto{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background: linear-gradient(90deg, rgba(255,204,0,.72), rgba(255,255,255,0));
      border:1px solid rgba(0,0,0,.12);
      border-radius: 18px;
      padding: 12px;
      margin-top: 10px;
    }
    .bigAuto .text{ display:flex; flex-direction:column; gap:2px; min-width: 240px; }
    .bigAuto .text b{ font-size: 13px; letter-spacing: .4px; }
    .bigAuto .text small{ font-size: 11px; color:var(--muted); font-weight: 900; }

    .abPills{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .pillActive{
      background: var(--wu);
      border-color: rgba(0,0,0,.18);
    }

    @media(max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      #waveform{ height: 90px; }
      .meterGrid{ grid-template-columns: 1fr; }
      input[type="range"]{ width: 250px; }
    }
  </style>
</head>

<body>
  <div class="app">

    <div class="card hero">
      <div class="row">
        <div class="brand">
          <div class="title">Wu Master <span class="badge">AUTO • A/B • REF</span></div>
          <div class="subtitle">Upload → Auto master → A/B compare (level-matched) → Export WAV</div>
        </div>

        <div class="btnbar">
          <span class="status" id="status">Load a track</span>
          <button class="btn ghost" id="playBtn" disabled>Play / Pause</button>
          <div class="abPills">
            <button class="btn pill ghost pillActive" id="abMasterBtn" disabled>MASTERED</button>
            <button class="btn pill ghost" id="abOriginalBtn" disabled>ORIGINAL</button>
          </div>
          <button class="btn primary" id="autoBtn" disabled>AUTO MASTER</button>
          <button class="btn ghost" id="resetBtn" disabled>Reset</button>
          <button class="btn primary" id="exportBtn" disabled>Export WAV</button>
        </div>
      </div>

      <div class="row">
        <div style="flex:1; min-width:280px;">
          <div class="sectionTitle">Your Track <span class="hint">master this</span></div>
          <input class="file" type="file" id="fileInput" accept="audio/*" />
        </div>
        <div style="flex:1; min-width:280px;">
          <div class="sectionTitle">Reference Track <span class="hint">match vibe (optional)</span></div>
          <input class="file" type="file" id="refInput" accept="audio/*" />
        </div>
      </div>

      <div id="waveform"></div>

      <div class="row">
        <div style="flex:1; min-width:230px;">
          <div class="sectionTitle">Auto Style / Feel <span class="hint">character</span></div>
          <select class="select" id="style">
            <option value="radio">Radio Pop (clean + bright)</option>
            <option value="warm90">Warm Tape 90s (round + thick)</option>
            <option value="rock">Rock Punch (transients + mids)</option>
            <option value="club">Club Loud (tight + loud)</option>
            <option value="lofi">Lo-Fi Cassette (grit + rolloff)</option>
            <option value="sunoFix" selected>Suno Fix (de-harsh + de-hiss + space)</option>
          </select>
        </div>

        <div style="flex:1; min-width:230px;">
          <div class="sectionTitle">Target <span class="hint">loudness vibe</span></div>
          <select class="select" id="target">
            <option value="stream" selected>Streaming Clean (-14-ish)</option>
            <option value="hot">Hot Pop / Loud (-11-ish)</option>
            <option value="clubhot">Club Smash (-9-ish)</option>
          </select>
        </div>

        <div style="flex:1; min-width:230px;">
          <div class="sectionTitle">Export <span class="hint">bit depth</span></div>
          <select class="select" id="bitDepth">
            <option value="24" selected>24-bit (recommended)</option>
            <option value="16">16-bit</option>
          </select>
        </div>
      </div>

      <div class="bigAuto">
        <div class="text">
          <b>Auto Intensity</b>
          <small>Safe → Aggressive (comp / clip / sparkle / width)</small>
        </div>
        <div style="flex:1; min-width:260px;">
          <div class="sliderLine">
            <label for="intensity">Intensity</label>
            <input type="range" id="intensity" min="0" max="100" value="60">
          </div>

          <div class="toggleLine">
            <div class="toggle">
              <input type="checkbox" id="levelMatch" checked>
              <label for="levelMatch">Level Match</label>
            </div>
            <div class="toggle">
              <input type="checkbox" id="monoBass" checked>
              <label for="monoBass">Mono Bass</label>
            </div>
            <div class="toggle">
              <input type="checkbox" id="widenAir" checked>
              <label for="widenAir">Widen Highs</label>
            </div>
            <div class="toggle">
              <input type="checkbox" id="spaceFX" checked>
              <label for="spaceFX">Air/Space</label>
            </div>
          </div>
        </div>
      </div>

      <div class="meterGrid">
        <div class="meter">
          <header><span>Peak (Wet)</span><span id="peakRead">-- dBFS</span></header>
          <canvas id="peakCanvas" width="900" height="140"></canvas>
        </div>
        <div class="meter">
          <header><span>RMS (Orig vs Master)</span><span id="rmsRead">-- dB</span></header>
          <canvas id="rmsCanvas" width="900" height="140"></canvas>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="sectionTitle">What’s new <span class="hint">based on your video extract</span></div>
      <div style="color:var(--muted); font-weight:900; font-size:12px; line-height:1.55;">
        • <b>A/B bus mindset</b>: Original vs Mastered is a real toggle (like “Suno mix” vs “mastered bus”).<br>
        • <b>Get loud first</b>: Auto pushes into the target loudness vibe, then shapes tone while loud.<br>
        • <b>Suno artifacts fix</b>: De-hiss + de-harsh dynamic band, plus rumble cleanup + smarter top end.<br>
        • <b>Drum punch logic</b>: Soft clipper before limiter helps transients get loud without pumping.<br>
      </div>
    </div>

    <div class="card">
      <div class="sectionTitle">Reality check <span class="hint">browser limits</span></div>
      <div style="color:var(--muted); font-weight:900; font-size:12px; line-height:1.55;">
        Web Audio can’t do “true” LUFS / linear-phase EQ like Ozone, but this chain is designed to be <b>consistent</b> and <b>better than raw Suno</b>.<br><br>
        If you want “near-pro” matching, upload a <b>reference file</b> (not a link) — the app can analyze it and steer the master toward its tilt/width.
      </div>
    </div>

  </div>

<script>
/* =========================
   Helpers
========================= */
const ui = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const db = (x)=>20*Math.log10(Math.max(1e-9,x));
const lin = (d)=>Math.pow(10,d/20);

function setStatus(msg){ ui("status").textContent = msg; }

function makeSaturationCurve(amount){
  const n=2048, curve=new Float32Array(n);
  const k=amount*18;
  for(let i=0;i<n;i++){
    const x=(i*2/n)-1;
    curve[i]=amount===0?x:Math.tanh(x*(1+k))/Math.tanh(1+k);
  }
  return curve;
}
function makeClipCurve(amount){
  const n=2048, curve=new Float32Array(n);
  const a=1+amount*12;
  for(let i=0;i<n;i++){
    const x=(i*2/n)-1;
    curve[i]=amount===0?x:(Math.atan(a*x)/Math.atan(a));
  }
  return curve;
}

/* =========================
   Audio State
========================= */
let audioCtx = null;
let mediaEl = null;
let mediaSource = null;
let wavesurfer = null;

let audioBuffer = null;     // your track (decoded)
let refBuffer = null;       // reference (decoded)
let fileNameBase = "WU_MASTER";

const nodes = {};
let rafId = null;

let currentAB = "master";   // "master" or "orig"

/* =========================
   WaveSurfer
========================= */
function initWaveSurfer(){
  if(wavesurfer) wavesurfer.destroy();
  wavesurfer = WaveSurfer.create({
    container:"#waveform",
    waveColor:"#0a0a0a",
    progressColor:"#ffcc00",
    cursorColor:"#ffcc00",
    height: matchMedia("(max-width: 980px)").matches ? 90 : 120,
    normalize:true,
    responsive:true,
    backend:"MediaElement"
  });
}

/* =========================
   Quick FFT (lightweight)
========================= */
function fftMag(x){
  const N=x.length;
  const re = new Float32Array(N);
  const im = new Float32Array(N);
  re.set(x);
  let j=0;
  for(let i=0;i<N;i++){
    if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; }
    let m=N>>1;
    while(m>=1 && j>=m){ j-=m; m>>=1; }
    j+=m;
  }
  for(let size=2; size<=N; size<<=1){
    const half=size>>1;
    const step=N/size;
    for(let i=0;i<N;i+=size){
      for(let k=0;k<half;k++){
        const ang = -2*Math.PI*k*step/N;
        const wr = Math.cos(ang), wi = Math.sin(ang);
        const a = i+k, b = i+k+half;
        const tr = wr*re[b] - wi*im[b];
        const ti = wr*im[b] + wi*re[b];
        re[b] = re[a]-tr; im[b]=im[a]-ti;
        re[a] = re[a]+tr; im[a]=im[a]+ti;
      }
    }
  }
  const out = new Float32Array(N/2);
  for(let i=0;i<N/2;i++) out[i] = Math.sqrt(re[i]*re[i] + im[i]*im[i]);
  return out;
}

function analyzeBuffer(buf){
  const ch0 = buf.getChannelData(0);
  const ch1 = buf.numberOfChannels>1 ? buf.getChannelData(1) : null;

  // peak + RMS
  let peak=0, sumSq=0;
  for(let i=0;i<ch0.length;i++){
    const a=Math.abs(ch0[i]); if(a>peak) peak=a;
    sumSq += ch0[i]*ch0[i];
    if(ch1){ const b=Math.abs(ch1[i]); if(b>peak) peak=b; sumSq += b*b; }
  }
  const n = ch1 ? ch0.length*2 : ch0.length;
  const rms = Math.sqrt(sumSq/Math.max(1,n));

  // short-ish loudness proxy: find loudest RMS window
  const sr = buf.sampleRate;
  const win = Math.max(2048, Math.floor(sr*0.25));
  const step = Math.floor(win/2);
  let best = 0;
  for(let i=0;i<ch0.length-win;i+=step){
    let s=0;
    for(let k=0;k<win;k++){
      const v = ch0[i+k];
      s += v*v;
      if(ch1){ const w = ch1[i+k]; s += w*w; }
    }
    const r = Math.sqrt(s/(win*(ch1?2:1)));
    if(r>best) best=r;
  }

  // spectrum snapshot
  const N = 4096;
  const seg = new Float32Array(N);
  const take = Math.min(ch0.length, sr*8);
  const stride = Math.max(1, Math.floor(take/N));
  for(let i=0;i<N;i++){
    const idx = Math.min(ch0.length-1, i*stride);
    seg[i] = ch0[idx];
  }
  const mags = fftMag(seg);
  const hzPerBin = sr/N;

  const band = (lo,hi)=>{
    const a=Math.floor(lo/hzPerBin);
    const b=Math.floor(hi/hzPerBin);
    let s=0,c=0;
    for(let i=a;i<=b && i<mags.length;i++){ s+=mags[i]; c++; }
    return s/Math.max(1,c);
  };

  const low = band(30,120);
  const mud = band(200,400);
  const mid = band(800,2000);
  const harsh = band(2500,5500);
  const air = band(10000,16000);
  const hiss = band(12000,20000); // proxy for noise/hiss

  // stereo correlation proxy
  let corr = 0.65;
  if(ch1){
    let num=0,denA=0,denB=0;
    const limit = Math.min(ch0.length, sr*3);
    for(let i=0;i<limit;i+=64){
      const a=ch0[i], b=ch1[i];
      num += a*b; denA += a*a; denB += b*b;
    }
    corr = num / Math.sqrt(Math.max(1e-9, denA*denB));
  }

  return {
    peakDb: db(peak),
    rmsDb: db(rms),
    loudRmsDb: db(best),
    low,mud,mid,harsh,air,hiss,
    corr
  };
}

/* =========================
   Graph: Dry vs Wet (A/B)
========================= */
function clearNodes(){
  try{ mediaSource?.disconnect(); }catch{}
  for(const k in nodes){
    try{ nodes[k]?.disconnect?.(); }catch{}
    delete nodes[k];
  }
}

function buildGraph(){
  clearNodes();

  nodes.masterOut = audioCtx.createGain();
  nodes.masterOut.gain.value = 1;
  nodes.masterOut.connect(audioCtx.destination);

  // A/B busses
  nodes.dryGain = audioCtx.createGain(); nodes.dryGain.gain.value = 0; // start on mastered
  nodes.wetGain = audioCtx.createGain(); nodes.wetGain.gain.value = 1;

  // Analysis meters
  nodes.anWet = audioCtx.createAnalyser(); nodes.anWet.fftSize=2048;
  nodes.anDry = audioCtx.createAnalyser(); nodes.anDry.fftSize=1024;

  // === Wet chain (AUTO MASTER BUS) ===
  nodes.inGain = audioCtx.createGain();

  // Foundation
  nodes.hpf = audioCtx.createBiquadFilter(); nodes.hpf.type="highpass"; nodes.hpf.Q.value=0.707;

  // Tonal/Surgical EQ
  nodes.eqLow = audioCtx.createBiquadFilter(); nodes.eqLow.type="lowshelf"; nodes.eqLow.frequency.value=90; nodes.eqLow.Q.value=0.707;
  nodes.eqMud = audioCtx.createBiquadFilter(); nodes.eqMud.type="peaking"; nodes.eqMud.frequency.value=280; nodes.eqMud.Q.value=1.0;
  nodes.eqHarsh = audioCtx.createBiquadFilter(); nodes.eqHarsh.type="peaking"; nodes.eqHarsh.frequency.value=3800; nodes.eqHarsh.Q.value=1.25;
  nodes.eqAir = audioCtx.createBiquadFilter(); nodes.eqAir.type="highshelf"; nodes.eqAir.frequency.value=12000; nodes.eqAir.Q.value=0.707;

  // De-hiss / De-harsh dynamic band (Suno-ish artifacts helper)
  nodes.dhBand = audioCtx.createBiquadFilter(); nodes.dhBand.type="bandpass"; nodes.dhBand.frequency.value=7000; nodes.dhBand.Q.value=2.6;
  nodes.dhComp = audioCtx.createDynamicsCompressor();
  nodes.dhComp.threshold.value=-30; nodes.dhComp.knee.value=20; nodes.dhComp.ratio.value=8;
  nodes.dhComp.attack.value=0.002; nodes.dhComp.release.value=0.11;
  nodes.dhMix = audioCtx.createGain();

  // Multiband-ish compression (3-band split)
  nodes.lowSplit = audioCtx.createBiquadFilter(); nodes.lowSplit.type="lowpass"; nodes.lowSplit.frequency.value=140; nodes.lowSplit.Q.value=0.707;
  nodes.midSplit = audioCtx.createBiquadFilter(); nodes.midSplit.type="bandpass"; nodes.midSplit.frequency.value=900; nodes.midSplit.Q.value=0.9;
  nodes.highSplit = audioCtx.createBiquadFilter(); nodes.highSplit.type="highpass"; nodes.highSplit.frequency.value=3200; nodes.highSplit.Q.value=0.707;

  nodes.compLow = audioCtx.createDynamicsCompressor();
  nodes.compMid = audioCtx.createDynamicsCompressor();
  nodes.compHigh = audioCtx.createDynamicsCompressor();

  // Glue (serial comp after multiband)
  nodes.glue = audioCtx.createDynamicsCompressor();
  nodes.glue.knee.value=18; nodes.glue.attack.value=0.03; nodes.glue.release.value=0.25;

  // Parallel “New York”
  nodes.nySend = audioCtx.createGain();
  nodes.nyComp = audioCtx.createDynamicsCompressor();
  nodes.nyComp.threshold.value=-30; nodes.nyComp.knee.value=12; nodes.nyComp.ratio.value=8;
  nodes.nyComp.attack.value=0.01; nodes.nyComp.release.value=0.12;
  nodes.nyReturn = audioCtx.createGain();

  // Mid/Side width (realtime)
  nodes.msIn = audioCtx.createGain();
  nodes.msOut = audioCtx.createGain();
  nodes.widthGain = audioCtx.createGain();

  const split = audioCtx.createChannelSplitter(2);
  const merge = audioCtx.createChannelMerger(2);

  const Lh = audioCtx.createGain(); Lh.gain.value=0.5;
  const Rh = audioCtx.createGain(); Rh.gain.value=0.5;
  const RhInv = audioCtx.createGain(); RhInv.gain.value=-0.5;
  const M = audioCtx.createGain();
  const S = audioCtx.createGain();
  const Sinv = audioCtx.createGain(); Sinv.gain.value=-1;
  const Lout = audioCtx.createGain();
  const Rout = audioCtx.createGain();

  nodes.sideHPF = audioCtx.createBiquadFilter(); nodes.sideHPF.type="highpass"; nodes.sideHPF.Q.value=0.707;
  nodes.sideHighHP = audioCtx.createBiquadFilter(); nodes.sideHighHP.type="highpass"; nodes.sideHighHP.frequency.value=8000; nodes.sideHighHP.Q.value=0.707;
  nodes.sideHighGain = audioCtx.createGain();

  nodes.msIn.connect(split);
  split.connect(Lh,0); split.connect(Rh,1); split.connect(RhInv,1);
  Lh.connect(M); Rh.connect(M);
  Lh.connect(S); RhInv.connect(S);

  const sideBase = audioCtx.createGain();
  const sideHighMix = audioCtx.createGain();
  const sideTotal = audioCtx.createGain();

  S.connect(nodes.sideHPF);
  nodes.sideHPF.connect(sideBase);

  nodes.sideHPF.connect(nodes.sideHighHP);
  nodes.sideHighHP.connect(nodes.sideHighGain);
  nodes.sideHighGain.connect(nodes.widthGain);
  nodes.widthGain.connect(sideHighMix);

  sideBase.connect(sideTotal);
  sideHighMix.connect(sideTotal);

  M.connect(Lout); sideTotal.connect(Lout);
  M.connect(Rout); sideTotal.connect(Sinv); Sinv.connect(Rout);

  Lout.connect(merge,0,0);
  Rout.connect(merge,0,1);
  merge.connect(nodes.msOut);

  // Character + Finish
  nodes.tape = audioCtx.createWaveShaper(); nodes.tape.oversample="2x";
  nodes.clip = audioCtx.createWaveShaper(); nodes.clip.oversample="4x";
  nodes.limiter = audioCtx.createDynamicsCompressor();
  nodes.limiter.knee.value=0; nodes.limiter.ratio.value=20; nodes.limiter.attack.value=0.002; nodes.limiter.release.value=0.08;

  // Subtle space (optional, inspired by “added delay/reverb” in your extract)
  nodes.spaceSend = audioCtx.createGain();
  nodes.spaceDelay = audioCtx.createDelay(0.5);
  nodes.spaceFb = audioCtx.createGain();
  nodes.spaceLP = audioCtx.createBiquadFilter(); nodes.spaceLP.type="lowpass"; nodes.spaceLP.frequency.value=6000;
  nodes.spaceMix = audioCtx.createGain();

  // routing
  mediaSource.connect(nodes.dryGain);
  nodes.dryGain.connect(nodes.anDry);
  nodes.anDry.connect(nodes.masterOut);

  mediaSource.connect(nodes.inGain);

  nodes.inGain.connect(nodes.hpf);
  nodes.hpf.connect(nodes.eqLow);
  nodes.eqLow.connect(nodes.eqMud);
  nodes.eqMud.connect(nodes.eqHarsh);
  nodes.eqHarsh.connect(nodes.eqAir);

  // dynamic de-hiss band (parallel)
  nodes.eqAir.connect(nodes.dhBand);
  nodes.dhBand.connect(nodes.dhComp);
  nodes.dhComp.connect(nodes.dhMix);

  // multiband split
  nodes.eqAir.connect(nodes.lowSplit);
  nodes.eqAir.connect(nodes.midSplit);
  nodes.eqAir.connect(nodes.highSplit);

  nodes.lowSplit.connect(nodes.compLow);
  nodes.midSplit.connect(nodes.compMid);
  nodes.highSplit.connect(nodes.compHigh);

  nodes.mbSum = audioCtx.createGain();
  nodes.compLow.connect(nodes.mbSum);
  nodes.compMid.connect(nodes.mbSum);
  nodes.compHigh.connect(nodes.mbSum);

  // add de-hiss mixed in
  nodes.dhMix.connect(nodes.mbSum);

  // glue
  nodes.mbSum.connect(nodes.glue);

  // parallel NY
  nodes.glue.connect(nodes.nySend);
  nodes.nySend.connect(nodes.nyComp);
  nodes.nyComp.connect(nodes.nyReturn);

  nodes.sum = audioCtx.createGain();
  nodes.glue.connect(nodes.sum);
  nodes.nyReturn.connect(nodes.sum);

  // optional space FX on wet bus
  nodes.sum.connect(nodes.spaceSend);
  nodes.spaceSend.connect(nodes.spaceDelay);
  nodes.spaceDelay.connect(nodes.spaceLP);
  nodes.spaceLP.connect(nodes.spaceFb);
  nodes.spaceFb.connect(nodes.spaceDelay);
  nodes.spaceLP.connect(nodes.spaceMix);

  // main path
  nodes.sum.connect(nodes.msIn);
  nodes.msOut.connect(nodes.tape);
  nodes.tape.connect(nodes.clip);
  nodes.clip.connect(nodes.limiter);

  // blend space in near the end (kept subtle)
  nodes.spaceMix.connect(nodes.limiter);

  nodes.limiter.connect(nodes.wetGain);
  nodes.wetGain.connect(nodes.anWet);
  nodes.anWet.connect(nodes.masterOut);

  applyAuto(); // initialize
  startMeters();
}

/* =========================
   Style presets (feel settings)
   + Ref steering
========================= */
function baseStyle(style){
  // These are baselines; auto analysis then nudges them
  switch(style){
    case "radio":
      return { air:+2.2, mud:-1.6, harsh:-1.0, low:+0.3, sat:0.35, clip:0.45, width:1.22, space:0.05 };
    case "warm90":
      return { air:+0.7, mud:-0.8, harsh:-0.6, low:+0.8, sat:0.55, clip:0.40, width:1.10, space:0.10 };
    case "rock":
      return { air:+1.2, mud:-1.2, harsh:-0.7, low:+0.4, sat:0.42, clip:0.62, width:1.15, space:0.06 };
    case "club":
      return { air:+1.0, mud:-2.2, harsh:-1.2, low:+0.9, sat:0.55, clip:0.78, width:1.12, space:0.03 };
    case "lofi":
      return { air:-0.6, mud:+0.2, harsh:-0.2, low:+0.3, sat:0.70, clip:0.35, width:1.05, space:0.12 };
    case "sunoFix":
    default:
      return { air:+1.4, mud:-2.0, harsh:-1.6, low:+0.4, sat:0.40, clip:0.55, width:1.15, space:0.08 };
  }
}

function computeAutoParams(){
  if(!audioBuffer) return null;

  const a = analyzeBuffer(audioBuffer);
  const style = ui("style").value;
  const target = ui("target").value;
  const intensity = Number(ui("intensity").value)/100;
  const monoBass = ui("monoBass").checked;
  const widenAir = ui("widenAir").checked;
  const spaceFX = ui("spaceFX").checked;

  const s = baseStyle(style);

  // Loudness target proxy (we use loudest RMS window and then push limiter/drive)
  // (Not true LUFS; but consistent across your own tracks)
  const desiredLoudRmsDb = (target==="stream") ? -16 : (target==="hot") ? -13 : -11;
  const pushDb = clamp(desiredLoudRmsDb - a.loudRmsDb, -6, 10);

  // Gain staging target headroom: aim peak around -4 dB before final
  const prePeakTarget = -4.5 + (target==="clubhot" ? 0.6 : 0) - intensity*0.4;
  const inputGainDb = clamp(prePeakTarget - a.peakDb, -12, 12);

  // Spectrum ratios
  const mudRatio = a.mud / Math.max(1e-9, a.mid);
  const harshRatio = a.harsh / Math.max(1e-9, a.mid);
  const airRatio = a.air / Math.max(1e-9, a.mid);
  const hissRatio = a.hiss / Math.max(1e-9, a.air);

  // Reference steering (optional): match tilt/width tendencies
  let ref = null;
  if(refBuffer){
    const r = analyzeBuffer(refBuffer);
    ref = {
      airToMid: r.air / Math.max(1e-9, r.mid),
      lowToMid: r.low / Math.max(1e-9, r.mid),
      corr: r.corr,
      harshToMid: r.harsh / Math.max(1e-9, r.mid),
      hissToAir: r.hiss / Math.max(1e-9, r.air)
    };
  }

  // EQ: style baseline + auto correction
  let mudDb   = s.mud - clamp(mudRatio*1.2 + intensity*1.2, 0.4, 3.8);
  let harshDb = s.harsh - clamp(harshRatio*1.1 + intensity*1.2, 0.3, 3.5);
  let airDb   = s.air + clamp((1.4 + intensity*1.6) - airRatio*1.2, -0.6, 3.6);
  let lowDb   = s.low + clamp(0.6 - (a.low/Math.max(1e-9,a.mid))*0.8, -1.2, 1.6);

  // Suno-fix: extra de-hiss tendency
  const dehissMix = clamp(0.25 + (style==="sunoFix" ? 0.25 : 0.10) + hissRatio*0.25 + intensity*0.20, 0.15, 0.80);

  // Reference influence (gentle)
  if(ref){
    const steer = 0.35; // keep it subtle
    const wantAir = clamp((ref.airToMid - airRatio), -1.0, 1.0);
    const wantLow = clamp((ref.lowToMid - (a.low/Math.max(1e-9,a.mid))), -1.0, 1.0);
    const wantHarsh = clamp((ref.harshToMid - harshRatio), -1.0, 1.0);

    airDb   += wantAir * 2.0 * steer;
    lowDb   += wantLow * 1.6 * steer;
    harshDb -= wantHarsh * 1.5 * steer; // more harsh -> tame more
  }

  // Compression settings (serial + multiband)
  const glueThresh = -22 - intensity*4 - (target==="clubhot" ? 2 : 0);
  const glueRatio  = 1.8 + intensity*1.0 + (target==="clubhot" ? 0.3 : 0);

  // Multiband thresholds: low controlled more, highs more open
  const lowT  = -24 - intensity*4 - (target==="clubhot" ? 2 : 0);
  const midT  = -22 - intensity*3;
  const highT = -20 - intensity*2;

  // Parallel NY
  const nyReturn = clamp(0.10 + intensity*0.25 + (style==="rock" ? 0.08 : 0), 0.08, 0.45);

  // Width
  let width = s.width;
  if(ref){
    // if ref is wider and ours is too mono -> widen slightly
    const refWide = (ref.corr < 0.45) ? 1.22 : 1.10;
    width = width + (refWide - width)*0.35;
  }
  width = widenAir ? width : 1.0;

  // Mono bass using side HPF
  const sideHPFHz = monoBass ? 200 : 5;

  // Saturation + clipping
  let satAmt = clamp(s.sat + intensity*0.35 + (target==="clubhot" ? 0.12 : 0), 0, 1);
  let clipAmt = clamp(s.clip + intensity*0.30 + (target==="clubhot" ? 0.12 : 0), 0, 1);

  // Space FX (tiny)
  const spaceAmt = spaceFX ? clamp(s.space + intensity*0.12, 0.0, 0.22) : 0.0;

  // Limiter ceiling (safe)
  const ceilingDb = -1.0;

  return {
    inputGainDb,
    pushDb,
    lowDb, mudDb, harshDb, airDb,
    dehissMix,
    glueThresh, glueRatio,
    lowT, midT, highT,
    nyReturn,
    sideHPFHz,
    width,
    satAmt,
    clipAmt,
    spaceAmt,
    ceilingDb
  };
}

function applyAuto(){
  if(!audioCtx || !nodes.inGain || !audioBuffer) return;

  const p = computeAutoParams();
  if(!p) return;

  nodes.inGain.gain.value = lin(p.inputGainDb);

  nodes.hpf.frequency.value = 30;

  nodes.eqLow.gain.value = p.lowDb;
  nodes.eqMud.gain.value = p.mudDb;
  nodes.eqHarsh.gain.value = p.harshDb;
  nodes.eqAir.gain.value = p.airDb;

  // de-hiss dynamic band mixed in
  nodes.dhMix.gain.value = p.dehissMix;

  // Multiband comps
  // Low: solid, more control
  nodes.compLow.threshold.value = p.lowT;
  nodes.compLow.knee.value = 18;
  nodes.compLow.ratio.value = 3.2;
  nodes.compLow.attack.value = 0.03;   // slowish attack preserves kick
  nodes.compLow.release.value = 0.18;

  // Mid: gentle glue
  nodes.compMid.threshold.value = p.midT;
  nodes.compMid.knee.value = 18;
  nodes.compMid.ratio.value = 2.2;
  nodes.compMid.attack.value = 0.025;
  nodes.compMid.release.value = 0.20;

  // High: light control (avoid dulling)
  nodes.compHigh.threshold.value = p.highT;
  nodes.compHigh.knee.value = 18;
  nodes.compHigh.ratio.value = 1.8;
  nodes.compHigh.attack.value = 0.015;
  nodes.compHigh.release.value = 0.14;

  // Glue
  nodes.glue.threshold.value = p.glueThresh;
  nodes.glue.ratio.value = p.glueRatio;

  // Parallel
  nodes.nyReturn.gain.value = p.nyReturn;

  // Width
  nodes.sideHPF.frequency.value = p.sideHPFHz;
  nodes.widthGain.gain.value = p.width;
  nodes.sideHighGain.gain.value = 1; // controlled by widthGain

  // Character
  nodes.tape.curve = makeSaturationCurve(p.satAmt);
  nodes.clip.curve = makeClipCurve(p.clipAmt);

  // Space FX
  nodes.spaceSend.gain.value = p.spaceAmt;
  nodes.spaceDelay.delayTime.value = 0.12;        // short slap
  nodes.spaceFb.gain.value = 0.20 + p.spaceAmt;   // gentle feedback
  nodes.spaceMix.gain.value = 0.35 * p.spaceAmt;  // keep subtle

  // Limiter
  nodes.limiter.threshold.value = p.ceilingDb;

  // Ensure current AB routing
  setAB(currentAB, false);
}

/* =========================
   A/B + Level Match
========================= */
function setAB(mode, updateUI=true){
  currentAB = mode;
  if(!nodes.wetGain || !nodes.dryGain) return;

  if(mode==="master"){
    nodes.wetGain.gain.value = 1;
    nodes.dryGain.gain.value = 0;
    if(updateUI){
      ui("abMasterBtn").classList.add("pillActive");
      ui("abOriginalBtn").classList.remove("pillActive");
      setStatus("A/B: MASTERED");
    }
  }else{
    nodes.wetGain.gain.value = 0;
    nodes.dryGain.gain.value = 1;
    if(updateUI){
      ui("abOriginalBtn").classList.add("pillActive");
      ui("abMasterBtn").classList.remove("pillActive");
      setStatus("A/B: ORIGINAL");
    }
  }
}

function startMeters(){
  if(rafId) cancelAnimationFrame(rafId);

  const peakC = ui("peakCanvas");
  const rmsC = ui("rmsCanvas");
  const pctx = peakC.getContext("2d");
  const rctx = rmsC.getContext("2d");

  const wetTime = new Float32Array(nodes.anWet.fftSize);
  const dryTime = new Float32Array(nodes.anDry.fftSize);

  function drawBar(ctx, valueDb, y, h, color){
    const w = ctx.canvas.width;
    ctx.fillStyle = "rgba(0,0,0,0.04)";
    ctx.fillRect(12, y, w-24, h);
    const frac = clamp((valueDb + 60)/60, 0, 1);
    ctx.fillStyle = color;
    ctx.fillRect(12, y, (w-24)*frac, h);
  }

  function loop(){
    nodes.anWet.getFloatTimeDomainData(wetTime);
    let peak=0, wetSum=0;
    for(let i=0;i<wetTime.length;i++){
      const v = wetTime[i];
      const a = Math.abs(v); if(a>peak) peak=a;
      wetSum += v*v;
    }
    const wetPeakDb = db(peak);
    const wetRms = Math.sqrt(wetSum / wetTime.length);
    const wetDb = db(wetRms);

    nodes.anDry.getFloatTimeDomainData(dryTime);
    let drySum=0;
    for(let i=0;i<dryTime.length;i++){
      const v = dryTime[i];
      drySum += v*v;
    }
    const dryRms = Math.sqrt(drySum / dryTime.length);
    const dryDb = db(dryRms);

    ui("peakRead").textContent = `${wetPeakDb.toFixed(1)} dBFS`;
    ui("rmsRead").textContent = `Orig ${dryDb.toFixed(1)} • Master ${wetDb.toFixed(1)} dB`;

    // Level match so A/B isn't a loudness trick
    if(ui("levelMatch").checked){
      if(currentAB==="master"){
        const diff = wetDb - dryDb; // if wet louder, turn wet down
        const target = clamp(lin(-diff), 0.55, 1.8);
        nodes.wetGain.gain.value += (target - nodes.wetGain.gain.value)*0.08;
        nodes.dryGain.gain.value = 0;
      }else{
        const diff = dryDb - wetDb;
        const target = clamp(lin(-diff), 0.55, 1.8);
        nodes.dryGain.gain.value += (target - nodes.dryGain.gain.value)*0.08;
        nodes.wetGain.gain.value = 0;
      }
    }else{
      // keep hard A/B
      if(currentAB==="master"){ nodes.wetGain.gain.value = 1; nodes.dryGain.gain.value=0; }
      else{ nodes.wetGain.gain.value = 0; nodes.dryGain.gain.value=1; }
    }

    // draw
    pctx.clearRect(0,0,peakC.width,peakC.height);
    drawBar(pctx, wetPeakDb, 40, 44, wetPeakDb > -1 ? "#ef4444" : (wetPeakDb > -6 ? "#f59e0b" : "#10b981"));
    pctx.fillStyle = "rgba(0,0,0,0.75)";
    pctx.font = "24px system-ui";
    pctx.fillText("PEAK", 12, 28);

    rctx.clearRect(0,0,rmsC.width,rmsC.height);
    drawBar(rctx, dryDb, 28, 32, "rgba(0,0,0,0.35)");
    drawBar(rctx, wetDb, 78, 32, "#ffcc00");
    rctx.fillStyle = "rgba(0,0,0,0.75)";
    rctx.font = "20px system-ui";
    rctx.fillText("RMS", 12, 22);

    rafId = requestAnimationFrame(loop);
  }
  loop();
}

/* =========================
   Loading
========================= */
function enableControls(on){
  ui("playBtn").disabled = !on;
  ui("abMasterBtn").disabled = !on;
  ui("abOriginalBtn").disabled = !on;
  ui("autoBtn").disabled = !on;
  ui("resetBtn").disabled = !on;
  ui("exportBtn").disabled = !on;
}

ui("fileInput").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;

  fileNameBase = (file.name||"WU_MASTER").replace(/\.[^/.]+$/,"");

  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  setStatus("Loading track…");
  const arr = await file.arrayBuffer();
  audioBuffer = await audioCtx.decodeAudioData(arr.slice(0));

  if(!mediaEl){
    mediaEl = new Audio();
    mediaEl.crossOrigin = "anonymous";
    mediaEl.preload = "auto";
  }
  mediaEl.pause();
  mediaEl.currentTime = 0;

  const url = URL.createObjectURL(file);
  mediaEl.src = url;

  initWaveSurfer();
  wavesurfer.load(url);

  try{
    if(mediaSource) { try{ mediaSource.disconnect(); }catch{} }
    mediaSource = audioCtx.createMediaElementSource(mediaEl);
  }catch(err){
    console.error(err);
    setStatus("Browser blocked audio. Use Chrome.");
    return;
  }

  buildGraph();
  setAB("master", true);
  enableControls(true);
  setStatus("Ready. Hit AUTO MASTER.");
});

ui("refInput").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) { refBuffer=null; return; }
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  setStatus("Loading reference…");
  const arr = await file.arrayBuffer();
  refBuffer = await audioCtx.decodeAudioData(arr.slice(0));
  setStatus("Reference loaded ✓ (Auto will steer toward it)");
  if(audioBuffer) applyAuto();
});

/* =========================
   Transport + Buttons
========================= */
ui("playBtn").addEventListener("click", async ()=>{
  if(!mediaEl || !audioCtx) return;
  if(audioCtx.state==="suspended") await audioCtx.resume();

  if(mediaEl.paused){
    await mediaEl.play();
    try{ wavesurfer.play(); }catch{}
    setStatus("Playing…");
  }else{
    mediaEl.pause();
    try{ wavesurfer.pause(); }catch{}
    setStatus("Paused.");
  }
});

ui("abMasterBtn").addEventListener("click", ()=> setAB("master", true));
ui("abOriginalBtn").addEventListener("click", ()=> setAB("orig", true));

ui("autoBtn").addEventListener("click", ()=>{
  if(!audioBuffer) return;
  setStatus("Auto mastering…");
  applyAuto();
  setStatus("Auto master ✓ A/B it (level matched).");
});

ui("resetBtn").addEventListener("click", ()=>{
  ui("style").value = "sunoFix";
  ui("target").value = "stream";
  ui("intensity").value = 60;
  ui("monoBass").checked = true;
  ui("widenAir").checked = true;
  ui("spaceFX").checked = true;
  ui("levelMatch").checked = true;
  refBuffer = null;
  ui("refInput").value = "";
  applyAuto();
  setAB("master", true);
  setStatus("Reset ✓");
});

["style","target","intensity","monoBass","widenAir","spaceFX","levelMatch"].forEach(id=>{
  ui(id).addEventListener("change", ()=>{ if(audioBuffer) applyAuto(); });
  ui(id).addEventListener("input", ()=>{ if(audioBuffer) applyAuto(); });
});

/* =========================
   Export (Offline render)
========================= */
function removeDCOffset(buf){
  const out = new AudioBuffer({ length: buf.length, numberOfChannels: buf.numberOfChannels, sampleRate: buf.sampleRate });
  for(let ch=0; ch<buf.numberOfChannels; ch++){
    const input=buf.getChannelData(ch);
    const data=out.getChannelData(ch);
    let mean=0;
    for(let i=0;i<input.length;i++) mean+=input[i];
    mean/=input.length;
    for(let i=0;i<input.length;i++) data[i]=input[i]-mean;
  }
  return out;
}

function audioBufferToWavBlob(buffer, bitDepth=24){
  const numChannels=buffer.numberOfChannels, sampleRate=buffer.sampleRate, length=buffer.length;
  const interleaved=new Float32Array(length*numChannels);
  const chans=[];
  for(let ch=0;ch<numChannels;ch++) chans.push(buffer.getChannelData(ch));
  for(let i=0;i<length;i++){
    for(let ch=0;ch<numChannels;ch++){
      interleaved[i*numChannels+ch]=chans[ch][i];
    }
  }

  const bytesPerSample = bitDepth===16 ? 2 : 3;
  const blockAlign = numChannels*bytesPerSample;
  const byteRate = sampleRate*blockAlign;
  const dataSize = interleaved.length*bytesPerSample;

  const ab = new ArrayBuffer(44+dataSize);
  const view = new DataView(ab);
  let o=0;
  const ws=(s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); };

  ws("RIFF"); view.setUint32(o, 36+dataSize, true); o+=4;
  ws("WAVE");
  ws("fmt "); view.setUint32(o,16,true); o+=4;
  view.setUint16(o,1,true); o+=2;
  view.setUint16(o,numChannels,true); o+=2;
  view.setUint32(o,sampleRate,true); o+=4;
  view.setUint32(o,byteRate,true); o+=4;
  view.setUint16(o,blockAlign,true); o+=2;
  view.setUint16(o,bitDepth,true); o+=2;
  ws("data"); view.setUint32(o,dataSize,true); o+=4;

  if(bitDepth===16){
    for(let i=0;i<interleaved.length;i++){
      const s=clamp(interleaved[i],-1,1);
      view.setInt16(o, s<0 ? s*0x8000 : s*0x7FFF, true);
      o+=2;
    }
  }else{
    for(let i=0;i<interleaved.length;i++){
      const s=clamp(interleaved[i],-1,1);
      let v = s<0 ? Math.floor(s*0x800000) : Math.floor(s*0x7FFFFF);
      view.setUint8(o++, v & 255);
      view.setUint8(o++, (v>>8)&255);
      view.setUint8(o++, (v>>16)&255);
    }
  }
  return new Blob([ab], {type:"audio/wav"});
}

ui("exportBtn").addEventListener("click", async ()=>{
  if(!audioBuffer) return;

  setStatus("Exporting…");
  const bitDepth = Number(ui("bitDepth").value);
  const cleaned = removeDCOffset(audioBuffer);

  const p = computeAutoParams();
  if(!p){ setStatus("Export failed (no params)."); return; }

  const offCtx = new OfflineAudioContext(cleaned.numberOfChannels, cleaned.length, cleaned.sampleRate);
  const src = offCtx.createBufferSource();
  src.buffer = cleaned;

  const inGain = offCtx.createGain(); inGain.gain.value = lin(p.inputGainDb);

  const hpf = offCtx.createBiquadFilter(); hpf.type="highpass"; hpf.Q.value=0.707; hpf.frequency.value=30;

  const eqLow = offCtx.createBiquadFilter(); eqLow.type="lowshelf"; eqLow.frequency.value=90; eqLow.Q.value=0.707; eqLow.gain.value=p.lowDb;
  const eqMud = offCtx.createBiquadFilter(); eqMud.type="peaking"; eqMud.frequency.value=280; eqMud.Q.value=1.0; eqMud.gain.value=p.mudDb;
  const eqHarsh = offCtx.createBiquadFilter(); eqHarsh.type="peaking"; eqHarsh.frequency.value=3800; eqHarsh.Q.value=1.25; eqHarsh.gain.value=p.harshDb;
  const eqAir = offCtx.createBiquadFilter(); eqAir.type="highshelf"; eqAir.frequency.value=12000; eqAir.Q.value=0.707; eqAir.gain.value=p.airDb;

  const dhBand = offCtx.createBiquadFilter(); dhBand.type="bandpass"; dhBand.frequency.value=7000; dhBand.Q.value=2.6;
  const dhComp = offCtx.createDynamicsCompressor();
  dhComp.threshold.value=-30; dhComp.knee.value=20; dhComp.ratio.value=8; dhComp.attack.value=0.002; dhComp.release.value=0.11;
  const dhMix = offCtx.createGain(); dhMix.gain.value=p.dehissMix;

  // 3-band comp
  const lowSplit = offCtx.createBiquadFilter(); lowSplit.type="lowpass"; lowSplit.frequency.value=140; lowSplit.Q.value=0.707;
  const midSplit = offCtx.createBiquadFilter(); midSplit.type="bandpass"; midSplit.frequency.value=900; midSplit.Q.value=0.9;
  const highSplit = offCtx.createBiquadFilter(); highSplit.type="highpass"; highSplit.frequency.value=3200; highSplit.Q.value=0.707;

  const compLow = offCtx.createDynamicsCompressor();
  compLow.threshold.value=p.lowT; compLow.knee.value=18; compLow.ratio.value=3.2; compLow.attack.value=0.03; compLow.release.value=0.18;

  const compMid = offCtx.createDynamicsCompressor();
  compMid.threshold.value=p.midT; compMid.knee.value=18; compMid.ratio.value=2.2; compMid.attack.value=0.025; compMid.release.value=0.20;

  const compHigh = offCtx.createDynamicsCompressor();
  compHigh.threshold.value=p.highT; compHigh.knee.value=18; compHigh.ratio.value=1.8; compHigh.attack.value=0.015; compHigh.release.value=0.14;

  const mbSum = offCtx.createGain();

  const glue = offCtx.createDynamicsCompressor();
  glue.threshold.value=p.glueThresh; glue.knee.value=18; glue.ratio.value=p.glueRatio; glue.attack.value=0.03; glue.release.value=0.25;

  const nyComp = offCtx.createDynamicsCompressor();
  nyComp.threshold.value=-30; nyComp.knee.value=12; nyComp.ratio.value=8; nyComp.attack.value=0.01; nyComp.release.value=0.12;
  const nyReturn = offCtx.createGain(); nyReturn.gain.value=p.nyReturn;

  const sum = offCtx.createGain();

  const tape = offCtx.createWaveShaper(); tape.oversample="2x"; tape.curve = makeSaturationCurve(p.satAmt);
  const clip = offCtx.createWaveShaper(); clip.oversample="4x"; clip.curve = makeClipCurve(p.clipAmt);

  const limiter = offCtx.createDynamicsCompressor();
  limiter.threshold.value=p.ceilingDb; limiter.knee.value=0; limiter.ratio.value=20; limiter.attack.value=0.002; limiter.release.value=0.08;

  // light space
  const spaceSend = offCtx.createGain(); spaceSend.gain.value = p.spaceAmt;
  const spaceDelay = offCtx.createDelay(0.5); spaceDelay.delayTime.value=0.12;
  const spaceLP = offCtx.createBiquadFilter(); spaceLP.type="lowpass"; spaceLP.frequency.value=6000;
  const spaceFb = offCtx.createGain(); spaceFb.gain.value=0.20 + p.spaceAmt;
  const spaceMix = offCtx.createGain(); spaceMix.gain.value = 0.35*p.spaceAmt;

  // route
  src.connect(inGain);
  inGain.connect(hpf);
  hpf.connect(eqLow); eqLow.connect(eqMud); eqMud.connect(eqHarsh); eqHarsh.connect(eqAir);

  // de-hiss parallel
  eqAir.connect(dhBand); dhBand.connect(dhComp); dhComp.connect(dhMix);

  // multiband
  eqAir.connect(lowSplit); eqAir.connect(midSplit); eqAir.connect(highSplit);
  lowSplit.connect(compLow); midSplit.connect(compMid); highSplit.connect(compHigh);
  compLow.connect(mbSum); compMid.connect(mbSum); compHigh.connect(mbSum);
  dhMix.connect(mbSum);

  // glue
  mbSum.connect(glue);

  // NY parallel
  glue.connect(nyComp);
  nyComp.connect(nyReturn);

  glue.connect(sum);
  nyReturn.connect(sum);

  // space
  sum.connect(spaceSend);
  spaceSend.connect(spaceDelay);
  spaceDelay.connect(spaceLP);
  spaceLP.connect(spaceFb);
  spaceFb.connect(spaceDelay);
  spaceLP.connect(spaceMix);

  // finish
  sum.connect(tape);
  tape.connect(clip);
  clip.connect(limiter);
  spaceMix.connect(limiter);
  limiter.connect(offCtx.destination);

  src.start(0);
  const rendered = await offCtx.startRendering();

  const blob = audioBufferToWavBlob(rendered, bitDepth);
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `${fileNameBase}_WU_MASTER_${bitDepth}bit.wav`;
  a.click();

  setStatus("Export complete ✅");
});
</script>
</body>
</html>
