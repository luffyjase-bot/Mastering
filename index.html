<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>JaseMaster — Auto Mastering (Bright Wu-Tang)</title>

  <!-- WaveSurfer (waveforms + playback) -->
  <script src="https://unpkg.com/wavesurfer.js@7"></script>

  <style>
    :root{
      --bg:#fffaf0;
      --panel:#ffffff;
      --ink:#111111;
      --muted:#555;
      --line:#e8e0c8;
      --yellow:#ffd400;
      --yellow2:#ffea7a;
      --shadow: 0 10px 30px rgba(17,17,17,.08);
      --radius: 18px;
      --danger:#d32f2f;
      --ok:#0b7a3b;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 10% 0%, var(--yellow2), transparent 60%),
        radial-gradient(1200px 700px at 90% 10%, var(--yellow), transparent 55%),
        linear-gradient(180deg, #fffef7 0%, var(--bg) 100%);
    }

    .wrap{
      max-width: 1180px;
      margin: 0 auto;
      padding: 14px 14px 48px;
    }

    header{
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px;
      padding: 10px 6px;
    }
    .brand{
      display:flex; flex-direction:column; gap:2px;
    }
    .brand h1{
      margin:0;
      font-size: 18px;
      letter-spacing: .2px;
    }
    .brand small{
      color:var(--muted);
      font-size: 12px;
    }

    .top-actions{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }

    .btn{
      border:1px solid #111;
      background: var(--panel);
      color:var(--ink);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      font-weight:700;
      box-shadow: 0 6px 0 rgba(17,17,17,.08);
      transition: transform .05s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: var(--yellow);
      border-color:#111;
    }
    .btn.ghost{
      background: transparent;
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      box-shadow:none;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 14px;
      align-items:start;
    }

    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .card-title{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap: 10px;
      margin-bottom: 10px;
    }
    .card-title h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .meta{
      color: var(--muted);
      font-size: 12px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
      text-align:right;
    }

    .wave{
      border-radius: 14px;
      background: #fff;
      border: 1px dashed var(--line);
      padding: 8px;
    }

    .player-row{
      display:flex; gap: 10px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      margin-top: 10px;
    }
    .player-controls{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    }

    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #fff;
      font-size: 12px;
      color: var(--ink);
      user-select:none;
    }

    .switch{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      color: var(--ink);
      user-select:none;
    }
    .switch input{ transform: scale(1.1); accent-color: var(--yellow); }

    .status{
      font-size: 12px;
      font-weight: 800;
      padding: 8px 10px;
      border-radius: 12px;
      border:1px solid var(--line);
      background:#fff;
      min-width: 160px;
      text-align:center;
    }
    .status.ok{ color: var(--ok); }
    .status.bad{ color: var(--danger); }

    .section{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .preset-bar{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .preset{
      border:1px solid #111;
      background: #fff;
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: 0 7px 0 rgba(17,17,17,.08);
      cursor:pointer;
      font-weight: 900;
      font-size: 12px;
      transition: transform .05s ease;
    }
    .preset:active{ transform: translateY(1px); }
    .preset.active{
      background: var(--yellow);
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 650px){
      .controls{ grid-template-columns: 1fr; }
    }

    .control{
      border:1px solid var(--line);
      border-radius: 14px;
      padding: 10px;
      background: #fff;
    }
    .control h3{
      margin:0 0 8px 0;
      font-size: 12px;
      letter-spacing:.2px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin: 8px 0;
      font-size: 12px;
      color: var(--ink);
    }

    input[type="range"]{
      width: 160px;
      accent-color: var(--yellow);
    }
    select, input[type="file"]{
      width: 100%;
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      background:#fff;
      font-weight:700;
    }

    .hint{
      display:flex;
      align-items:center;
      gap: 8px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.3;
      margin-top: 10px;
    }

    /* Tooltips */
    .tip{
      position:relative;
      display:inline-flex;
      align-items:center;
      gap: 6px;
      font-weight: 800;
    }
    .q{
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid #111;
      display:inline-grid;
      place-items:center;
      font-size: 12px;
      background: var(--yellow);
      cursor: help;
      user-select:none;
    }
    .q::after{
      content: attr(data-tip);
      position:absolute;
      left: 0;
      bottom: calc(100% + 10px);
      width: min(300px, 70vw);
      background:#111;
      color:#fff;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      opacity: 0;
      transform: translateY(6px);
      pointer-events:none;
      transition: .12s ease;
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      z-index: 20;
      white-space: normal;
    }
    .q::before{
      content:"";
      position:absolute;
      left: 12px;
      bottom: calc(100% + 4px);
      width: 10px;
      height: 10px;
      background:#111;
      transform: rotate(45deg);
      opacity: 0;
      transition: .12s ease;
      z-index: 19;
    }
    .q:hover::after, .q:hover::before{ opacity:1; transform: translateY(0); }

    /* Mobile: allow tap focus tooltip */
    .q:focus::after, .q:focus::before{ opacity:1; transform: translateY(0); }
    .q{ outline: none; }

    .warn{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid #111;
      background: #fff;
      font-size: 12px;
      font-weight: 800;
      display:none;
    }
    .warn.show{ display:block; }
    .warn.bad{ border-color: var(--danger); color: var(--danger); }
    .warn.ok{ border-color: var(--ok); color: var(--ok); }

    footer{
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      line-height:1.4;
      padding: 0 6px;
    }
    code{
      background:#111;
      color:#fff;
      padding:2px 6px;
      border-radius: 8px;
      font-weight: 800;
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <h1>JaseMaster</h1>
      <small>Auto mastering (sane, not bullying) • Bright Wu-Tang Yellow Edition</small>
    </div>
    <div class="top-actions">
      <button class="btn primary" id="autoBtn" disabled>Auto-Master</button>
      <button class="btn" id="exportBtn" disabled>Export WAV</button>
      <button class="btn ghost" id="resetBtn">Reset</button>
    </div>
  </header>

  <div class="grid">
    <!-- LEFT: Players -->
    <div class="section">
      <!-- Original -->
      <div class="card">
        <div class="card-title">
          <h2>Original</h2>
          <div class="meta" id="origMeta">No file loaded</div>
        </div>
        <input type="file" id="origFile" accept="audio/*" />
        <div class="wave" id="waveOrig"></div>
        <div class="player-row">
          <div class="player-controls">
            <button class="btn" id="oPlay" disabled>Play</button>
            <button class="btn" id="oPause" disabled>Pause</button>
            <button class="btn" id="oStop" disabled>Stop</button>
          </div>
          <div class="pill" id="origStats">Peak: — • RMS: — • LUFS-ish: —</div>
        </div>
      </div>

      <!-- Mastered -->
      <div class="card">
        <div class="card-title">
          <h2>Mastered</h2>
          <div class="meta" id="mastMeta">Not generated yet</div>
        </div>
        <div class="wave" id="waveMast"></div>
        <div class="player-row">
          <div class="player-controls">
            <button class="btn" id="mPlay" disabled>Play</button>
            <button class="btn" id="mPause" disabled>Pause</button>
            <button class="btn" id="mStop" disabled>Stop</button>
            <label class="switch">
              <input type="checkbox" id="lvlMatch" checked />
              Level-match A/B
            </label>
          </div>
          <div class="pill" id="mastStats">Peak: — • RMS: — • LUFS-ish: —</div>
        </div>

        <div class="hint">
          <span class="q" tabindex="0" data-tip="Level-match makes Original and Mastered play at similar volume so you judge tone + clarity, not loudness tricks.">?</span>
          <span>If Mastered looks “maxed,” that’s usually fake normalization. This tool shows real peaks and keeps output under your ceiling.</span>
        </div>

        <div class="warn" id="warnBox"></div>
      </div>

      <!-- Reference -->
      <div class="card">
        <div class="card-title">
          <h2>Reference (optional)</h2>
          <div class="meta" id="refMeta">Use a pro track vibe to guide width + tonal tilt</div>
        </div>
        <input type="file" id="refFile" accept="audio/*" />
        <div class="wave" id="waveRef"></div>
        <div class="player-row">
          <div class="player-controls">
            <button class="btn" id="rPlay" disabled>Play</button>
            <button class="btn" id="rPause" disabled>Pause</button>
            <button class="btn" id="rStop" disabled>Stop</button>
            <label class="switch">
              <input type="checkbox" id="useRef" />
              Use Reference in Auto-Master
            </label>
          </div>
          <div class="pill" id="refStats">Peak: — • RMS: — • LUFS-ish: —</div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Controls -->
    <div class="section">
      <div class="card">
        <div class="card-title">
          <h2>One-Click Styles</h2>
          <div class="meta">
            <span id="status" class="status">Load an Original</span>
          </div>
        </div>

        <div class="preset-bar" id="presetBar">
          <button class="preset" data-style="worship">Upbeat Worship</button>
          <button class="preset" data-style="poppunch">Pop Punch</button>
          <button class="preset" data-style="rockedge">Rock Edge</button>
          <button class="preset" data-style="lofiwarm">Lo-Fi Warm</button>
          <button class="preset" data-style="clubhot">Club Hot</button>
        </div>

        <div class="hint" style="margin-top:12px;">
          <span class="q" tabindex="0" data-tip="These presets set the mastering chain for you (EQ/comp/width/limit). Then you hit Auto-Master.">?</span>
          <span>Pick a style → tap <b>Auto-Master</b>. No fiddling needed.</span>
        </div>
      </div>

      <div class="card">
        <div class="card-title">
          <h2>Auto-Master Settings</h2>
          <div class="meta"><span class="pill" id="styleSummary">Style: —</span></div>
        </div>

        <div class="controls">
          <div class="control">
            <h3>
              <span class="tip">Output Target
                <span class="q" tabindex="0" data-tip="Streaming is safer and cleaner. 'Loud' is more aggressive. 'Hot' can distort if the mix is messy.">?</span>
              </span>
            </h3>
            <div class="row">
              <label for="target">Target</label>
              <select id="target">
                <option value="-14">Streaming (≈ -14 LUFS-ish)</option>
                <option value="-11">Loud Pop (≈ -11 LUFS-ish)</option>
                <option value="-9">Hot Club (≈ -9 LUFS-ish)</option>
              </select>
            </div>
            <div class="row">
              <span class="tip">Ceiling
                <span class="q" tabindex="0" data-tip="Max peak output. -1.0 dB is safer for mp3/aac conversion and avoids clipping.">?</span>
              </span>
              <input type="range" id="ceiling" min="-3" max="0" step="0.1" value="-1.0">
              <span id="ceilingVal">-1.0 dB</span>
            </div>
            <div class="row">
              <span class="tip">Intensity
                <span class="q" tabindex="0" data-tip="How hard the chain pushes compression/saturation/limiting. Keep 30–55 for clean. 70+ gets spicy.">?</span>
              </span>
              <input type="range" id="intensity" min="0" max="100" step="1" value="40">
              <span id="intensityVal">40%</span>
            </div>
          </div>

          <div class="control">
            <h3>
              <span class="tip">Cleanup EQ
                <span class="q" tabindex="0" data-tip="These reduce rumble, mud, and harshness before getting loud. This is where ‘pro’ starts.">?</span>
              </span>
            </h3>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="hpf" checked>
                HPF 30 Hz
              </label>
              <span class="q" tabindex="0" data-tip="Removes useless sub-rumble that steals headroom.">?</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="mud" checked>
                Cut Mud (300 Hz)
              </label>
              <span class="q" tabindex="0" data-tip="Gently reduces boxy low-mids that make mixes feel cloudy.">?</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="deharsh" checked>
                De-Harsh (3.5 kHz)
              </label>
              <span class="q" tabindex="0" data-tip="Tames harsh presence so loud masters don’t stab your ears.">?</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="air" checked>
                Add Air (12 kHz)
              </label>
              <span class="q" tabindex="0" data-tip="Adds ‘expensive’ sparkle—don’t overdo if your vocal already hisses.">?</span>
            </div>
          </div>

          <div class="control">
            <h3>
              <span class="tip">Dynamics
                <span class="q" tabindex="0" data-tip="Glue + Parallel adds weight and control without murdering transients.">?</span>
              </span>
            </h3>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="glue" checked>
                Glue Compression
              </label>
              <span class="q" tabindex="0" data-tip="A gentle compressor for cohesion. Not a brickwall.">?</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="parallel" checked>
                Parallel (New York)
              </label>
              <span class="q" tabindex="0" data-tip="Blends a crushed copy under the clean signal for energy.">?</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="multiband" checked>
                Multiband-ish Control
              </label>
              <span class="q" tabindex="0" data-tip="Tightens lows a bit more than highs (approx). Helps bass feel solid.">?</span>
            </div>
          </div>

          <div class="control">
            <h3>
              <span class="tip">Stereo + Character
                <span class="q" tabindex="0" data-tip="Width can be addictive. Keep it subtle to avoid phase weirdness.">?</span>
              </span>
            </h3>
            <div class="row">
              <span class="tip">Width
                <span class="q" tabindex="0" data-tip="Boosts the Side channel. 1.10–1.30 is usually plenty.">?</span>
              </span>
              <input type="range" id="width" min="1.0" max="1.6" step="0.01" value="1.18">
              <span id="widthVal">1.18x</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="monoBass" checked>
                Mono Bass (<120 Hz)
              </label>
              <span class="q" tabindex="0" data-tip="Forces sub-bass towards mono for tighter club translation.">?</span>
            </div>
            <div class="row">
              <label class="switch">
                <input type="checkbox" id="warmth" checked>
                Warmth (Tape-ish)
              </label>
              <span class="q" tabindex="0" data-tip="Gentle saturation for perceived loudness and thickness.">?</span>
            </div>
          </div>
        </div>

        <div class="hint">
          <span class="q" tabindex="0" data-tip="If it sounds nasty: drop Intensity to 25–40, choose Streaming target, and keep Air on (but warmth lower).">?</span>
          <span><b>Rule:</b> If it gets louder but worse, that’s not mastering — it’s violence. Dial it back.</span>
        </div>
      </div>

      <footer class="card">
        <b>GitHub Pages quick setup:</b><br/>
        Put this file at repo root named <code>index.html</code> → GitHub → repo → <code>Settings</code> → <code>Pages</code> → Source: <code>Deploy from a branch</code> → Branch: <code>main</code> / <code>root</code>.
        Then open: <code>https://YOURUSERNAME.github.io/REPO</code>
      </footer>
    </div>
  </div>
</div>

<script>
/* ===========================
   Small utilities
=========================== */
const $ = (id)=>document.getElementById(id);
const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
const dbToGain = (db)=>Math.pow(10, db/20);
const gainToDb = (g)=>20*Math.log10(Math.max(1e-9, g));

function setStatus(text, ok=true){
  const el = $("status");
  el.textContent = text;
  el.classList.toggle("ok", ok);
  el.classList.toggle("bad", !ok);
}

function warn(msg, ok=false){
  const w = $("warnBox");
  if(!msg){ w.className="warn"; w.textContent=""; return; }
  w.className = "warn show " + (ok ? "ok" : "bad");
  w.textContent = msg;
}

function fmtHz(sr){ return (sr/1000).toFixed(1) + " kHz"; }
function fmt(n, d=1){ return Number(n).toFixed(d); }

/* ===========================
   Analysis (fast-ish, browser-safe)
=========================== */
function getPeak(buffer){
  let peak = 0;
  for(let ch=0; ch<buffer.numberOfChannels; ch++){
    const d = buffer.getChannelData(ch);
    for(let i=0; i<d.length; i++){
      const a = Math.abs(d[i]);
      if(a>peak) peak=a;
    }
  }
  return peak;
}

function getRMS(buffer){
  let sum = 0;
  let count = 0;
  for(let ch=0; ch<buffer.numberOfChannels; ch++){
    const d = buffer.getChannelData(ch);
    for(let i=0; i<d.length; i++){
      const v = d[i];
      sum += v*v;
      count++;
    }
  }
  return Math.sqrt(sum / Math.max(1, count));
}

// "LUFS-ish": not true K-weighted LUFS, but good enough for relative sanity checks
function lufsIshFromRMS(rms){
  // Calibrated so a typical full mix feels roughly in the ballpark
  // (You can treat it like "loudness-ish" rather than real LUFS.)
  return (gainToDb(rms) - 0.0);
}

function makeStats(buffer){
  const peak = getPeak(buffer);
  const rms = getRMS(buffer);
  return {
    ch: buffer.numberOfChannels,
    sr: buffer.sampleRate,
    peak,
    peakDb: gainToDb(peak),
    rms,
    rmsDb: gainToDb(rms),
    lufsIsh: lufsIshFromRMS(rms)
  };
}

/* ===========================
   WAV export
=========================== */
function audioBufferToWav(buffer, bitDepth=24){
  const numCh = buffer.numberOfChannels;
  const sr = buffer.sampleRate;
  const len = buffer.length;

  // interleave
  const inter = new Float32Array(len * numCh);
  for(let i=0; i<len; i++){
    for(let ch=0; ch<numCh; ch++){
      inter[i*numCh + ch] = buffer.getChannelData(ch)[i];
    }
  }

  const bytesPerSample = bitDepth === 16 ? 2 : (bitDepth === 32 ? 4 : 3);
  const blockAlign = numCh * bytesPerSample;
  const dataSize = inter.length * bytesPerSample;
  const bufferSize = 44 + dataSize;

  const out = new ArrayBuffer(bufferSize);
  const view = new DataView(out);

  function writeStr(off, s){ for(let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i)); }

  // RIFF
  writeStr(0,"RIFF");
  view.setUint32(4, 36 + dataSize, true);
  writeStr(8,"WAVE");

  // fmt
  writeStr(12,"fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true); // PCM
  view.setUint16(22, numCh, true);
  view.setUint32(24, sr, true);
  view.setUint32(28, sr * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);

  // data
  writeStr(36,"data");
  view.setUint32(40, dataSize, true);

  let offset = 44;
  for(let i=0; i<inter.length; i++){
    let s = clamp(inter[i], -1, 1);

    if(bitDepth === 16){
      const v = s < 0 ? s * 0x8000 : s * 0x7FFF;
      view.setInt16(offset, v, true);
      offset += 2;
    } else if(bitDepth === 24){
      // 24-bit signed
      const v = Math.round((s < 0 ? s * 0x800000 : s * 0x7FFFFF));
      view.setUint8(offset, (v & 0xFF)); offset++;
      view.setUint8(offset, ((v >> 8) & 0xFF)); offset++;
      view.setUint8(offset, ((v >> 16) & 0xFF)); offset++;
    } else {
      view.setFloat32(offset, s, true);
      offset += 4;
    }
  }
  return out;
}

function downloadBlob(blob, name){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}

/* ===========================
   Very light reference analysis (3 band energies)
   Not "Matchering", but gives usable "tilt guidance"
=========================== */
function bandEnergies(buffer){
  // one-pole filters to estimate energy in bands
  const sr = buffer.sampleRate;
  const ch = buffer.numberOfChannels;
  const len = buffer.length;

  const fcLow = 150;
  const fcMid = 2000;
  const aLow = 1 - Math.exp(-2*Math.PI*fcLow/sr);
  const aMid = 1 - Math.exp(-2*Math.PI*fcMid/sr);

  let eLow=0, eMid=0, eHigh=0, count=0;

  for(let c=0;c<ch;c++){
    const d = buffer.getChannelData(c);
    let low=0, midLP=0;
    for(let i=0;i<len;i++){
      const x = d[i];
      // lowpass @150
      low = low + aLow*(x - low);
      // lowpass @2000
      midLP = midLP + aMid*(x - midLP);

      const high = x - midLP;      // above ~2k
      const mid = midLP - low;     // ~150-2k

      eLow += low*low;
      eMid += mid*mid;
      eHigh += high*high;
      count++;
    }
  }

  return {
    low: Math.sqrt(eLow/Math.max(1,count)),
    mid: Math.sqrt(eMid/Math.max(1,count)),
    high: Math.sqrt(eHigh/Math.max(1,count))
  };
}

/* ===========================
   DSP: saturation & clipping via waveshaper
=========================== */
function makeSaturator(ctx, amount=0.8){
  const ws = ctx.createWaveShaper();
  ws.oversample = "4x";
  const n = 2048;
  const curve = new Float32Array(n);
  const k = 1 + amount * 20;
  for(let i=0;i<n;i++){
    const x = (i/(n-1))*2 - 1;
    curve[i] = Math.tanh(k*x) / Math.tanh(k);
  }
  ws.curve = curve;
  return ws;
}

function makeClipper(ctx, amount=0.25){
  // Soft clip
  const ws = ctx.createWaveShaper();
  ws.oversample = "4x";
  const n = 2048;
  const curve = new Float32Array(n);
  const k = 1 + amount * 50;
  for(let i=0;i<n;i++){
    const x = (i/(n-1))*2 - 1;
    // soft clip
    curve[i] = (Math.atan(k*x) / Math.atan(k));
  }
  ws.curve = curve;
  return ws;
}

/* ===========================
   Master render (OfflineAudioContext)
=========================== */
async function renderMaster(origBuffer, refBuffer, settings){
  const sr = origBuffer.sampleRate;
  const len = origBuffer.length;
  const ch = origBuffer.numberOfChannels;

  const off = new OfflineAudioContext(ch, len, sr);
  const src = off.createBufferSource();
  src.buffer = origBuffer;

  // Pre gain to hit headroom (~-6 dB peak)
  const pre = off.createGain();
  pre.gain.value = dbToGain(settings.preGainDb);

  // Cleanup EQ
  const hpf = off.createBiquadFilter();
  hpf.type="highpass"; hpf.frequency.value = 30; hpf.Q.value = 0.707;

  const mud = off.createBiquadFilter();
  mud.type="peaking"; mud.frequency.value = 300; mud.Q.value = 1.0; mud.gain.value = settings.mudOn ? -1.2 : 0;

  const deharsh = off.createBiquadFilter();
  deharsh.type="peaking"; deharsh.frequency.value = 3500; deharsh.Q.value = 1.2; deharsh.gain.value = settings.deharshOn ? -1.0 : 0;

  const air = off.createBiquadFilter();
  air.type="highshelf"; air.frequency.value = 12000; air.gain.value = settings.airOn ? 1.2 : 0;

  // Reference "tilt" (small EQ nudges based on band energies)
  // Keep this subtle (<= +/-2 dB) so it helps without wrecking things.
  const tiltLow = off.createBiquadFilter();
  tiltLow.type="lowshelf"; tiltLow.frequency.value = 160; tiltLow.gain.value = 0;

  const tiltHigh = off.createBiquadFilter();
  tiltHigh.type="highshelf"; tiltHigh.frequency.value = 9000; tiltHigh.gain.value = 0;

  if(settings.useRef && refBuffer){
    const t = bandEnergies(origBuffer);
    const r = bandEnergies(refBuffer);

    const lowDb = clamp(gainToDb(r.low) - gainToDb(t.low), -2, 2);
    const highDb = clamp(gainToDb(r.high) - gainToDb(t.high), -2, 2);

    tiltLow.gain.value = lowDb;
    tiltHigh.gain.value = highDb;
  }

  // Dynamics
  const glue = off.createDynamicsCompressor();
  glue.threshold.value = settings.glueOn ? (-22 - settings.intensity*0.10) : 0;
  glue.ratio.value = settings.glueOn ? 2.2 : 1;
  glue.attack.value = 0.03;   // slow-ish
  glue.release.value = 0.18;
  glue.knee.value = 18;

  // Multiband-ish (approx): tighten lows a bit
  const lowSplit = off.createBiquadFilter();
  lowSplit.type="lowpass"; lowSplit.frequency.value = 180; lowSplit.Q.value = 0.707;

  const lowComp = off.createDynamicsCompressor();
  lowComp.threshold.value = settings.multiband ? (-26 - settings.intensity*0.12) : 0;
  lowComp.ratio.value = settings.multiband ? 2.8 : 1;
  lowComp.attack.value = 0.02;
  lowComp.release.value = 0.12;
  lowComp.knee.value = 14;

  const lowGain = off.createGain();
  lowGain.gain.value = settings.multiband ? 0.98 : 1;

  // Saturation
  const sat = makeSaturator(off, settings.warmthOn ? (0.55 + settings.intensity/200) : 0.18);

  // Parallel comp
  const dry = off.createGain();
  dry.gain.value = 1.0;

  const parComp = off.createDynamicsCompressor();
  parComp.threshold.value = -34 - settings.intensity*0.25;
  parComp.ratio.value = 6.0;
  parComp.attack.value = 0.01;
  parComp.release.value = 0.12;
  parComp.knee.value = 22;

  const parMix = off.createGain();
  parMix.gain.value = settings.parallelOn ? (0.10 + settings.intensity/300) : 0.0;

  const sum = off.createGain();
  sum.gain.value = 1.0;

  // Stereo width + mono bass (mid/side)
  // Build M/S matrix: mid=(L+R)/2, side=(L-R)/2
  const splitter = off.createChannelSplitter(2);
  const merger = off.createChannelMerger(2);

  const gL = off.createGain(); gL.gain.value = 0.5;
  const gR = off.createGain(); gR.gain.value = 0.5;
  const invR = off.createGain(); invR.gain.value = -0.5;

  const mid = off.createGain();
  const side = off.createGain();

  // side width gain
  const sideGain = off.createGain();
  sideGain.gain.value = settings.width;

  // mono bass: highpass sides at 120 Hz
  const sideHP = off.createBiquadFilter();
  sideHP.type="highpass"; sideHP.frequency.value = 120; sideHP.Q.value = 0.707;

  // Reconstruct L = mid + side, R = mid - side
  const toL_mid = off.createGain(); toL_mid.gain.value = 1.0;
  const toL_side = off.createGain(); toL_side.gain.value = 1.0;

  const toR_mid = off.createGain(); toR_mid.gain.value = 1.0;
  const toR_side = off.createGain(); toR_side.gain.value = -1.0;

  // Clipper + Limiter
  const clip = makeClipper(off, 0.18 + settings.intensity/220);

  const limiter = off.createDynamicsCompressor();
  limiter.threshold.value = -8 - settings.intensity*0.08; // push more with intensity
  limiter.ratio.value = 18;
  limiter.attack.value = 0.003;
  limiter.release.value = 0.12;
  limiter.knee.value = 0;

  const outGain = off.createGain();
  outGain.gain.value = 1.0;

  // ROUTING
  src.connect(pre);

  let chain = pre;
  if(settings.hpfOn) { chain.connect(hpf); chain = hpf; }
  chain.connect(mud); chain = mud;
  chain.connect(deharsh); chain = deharsh;
  chain.connect(air); chain = air;
  chain.connect(tiltLow); chain = tiltLow;
  chain.connect(tiltHigh); chain = tiltHigh;

  // glue
  chain.connect(glue);
  chain = glue;

  // low multiband branch
  if(settings.multiband){
    chain.connect(lowSplit);
    lowSplit.connect(lowComp);
    lowComp.connect(lowGain);
    lowGain.connect(sum);
  }

  // saturation then split for parallel
  chain.connect(sat);

  // dry path
  sat.connect(dry);
  dry.connect(sum);

  // parallel comp path
  sat.connect(parComp);
  parComp.connect(parMix);
  parMix.connect(sum);

  // Mid/Side (only if stereo)
  if(ch >= 2){
    sum.connect(splitter);

    splitter.connect(gL, 0);
    splitter.connect(gR, 1);
    splitter.connect(invR, 1);

    // mid = 0.5L + 0.5R
    gL.connect(mid);
    gR.connect(mid);

    // side = 0.5L - 0.5R
    gL.connect(side);
    invR.connect(side);

    side.connect(sideGain);

    if(settings.monoBass){
      sideGain.connect(sideHP);
    }

    const sideNode = settings.monoBass ? sideHP : sideGain;

    // L = mid + side
    mid.connect(toL_mid);
    sideNode.connect(toL_side);
    toL_mid.connect(merger, 0, 0);
    toL_side.connect(merger, 0, 0);

    // R = mid - side
    mid.connect(toR_mid);
    sideNode.connect(toR_side);
    toR_mid.connect(merger, 0, 1);
    toR_side.connect(merger, 0, 1);

    merger.connect(clip);
  } else {
    // mono
    sum.connect(clip);
  }

  clip.connect(limiter);
  limiter.connect(outGain);
  outGain.connect(off.destination);

  src.start(0);
  const rendered = await off.startRendering();

  return rendered;
}

/* ===========================
   Final normalization & level target
=========================== */
function applyGainBuffer(buffer, gain){
  const out = new AudioBuffer({
    length: buffer.length,
    numberOfChannels: buffer.numberOfChannels,
    sampleRate: buffer.sampleRate
  });
  for(let ch=0; ch<buffer.numberOfChannels; ch++){
    const s = buffer.getChannelData(ch);
    const d = out.getChannelData(ch);
    for(let i=0;i<s.length;i++){
      d[i] = s[i] * gain;
    }
  }
  return out;
}

function normalizeToCeiling(buffer, ceilingDb){
  const peak = getPeak(buffer);
  if(peak <= 0) return buffer;
  const target = dbToGain(ceilingDb);
  const g = target / peak;
  return applyGainBuffer(buffer, g);
}

function hitTargetLufsIsh(buffer, targetLufsIsh){
  // Use RMS-based estimate. Keep changes limited so it doesn’t explode.
  const st = makeStats(buffer);
  const delta = targetLufsIsh - st.lufsIsh;  // dB change needed
  const capped = clamp(delta, -12, 12);
  const g = dbToGain(capped);
  return applyGainBuffer(buffer, g);
}

/* ===========================
   State + WaveSurfer players
=========================== */
let audioCtx = null;

const state = {
  style: null,
  orig: { buffer:null, ws:null, url:null, stats:null },
  mast: { buffer:null, ws:null, url:null, stats:null },
  ref:  { buffer:null, ws:null, url:null, stats:null }
};

function makeWS(container){
  return WaveSurfer.create({
    container,
    height: 84,
    waveColor: "#111111",
    progressColor: "#ffd400",
    cursorColor: "#111111",
    barWidth: 2,
    barGap: 1,
    normalize: false,  // IMPORTANT: show real peaks
    responsive: true
  });
}

async function loadIntoWS(ws, url){
  await ws.load(url);
}

function stopAll(){
  [state.orig.ws, state.mast.ws, state.ref.ws].forEach(ws=>{
    if(ws){ try{ ws.stop(); }catch(e){} }
  });
}

function enableOrigControls(on){
  $("oPlay").disabled = !on; $("oPause").disabled = !on; $("oStop").disabled = !on;
}
function enableMastControls(on){
  $("mPlay").disabled = !on; $("mPause").disabled = !on; $("mStop").disabled = !on;
  $("exportBtn").disabled = !on;
}
function enableRefControls(on){
  $("rPlay").disabled = !on; $("rPause").disabled = !on; $("rStop").disabled = !on;
}

/* ===========================
   UI sync
=========================== */
function syncRanges(){
  $("ceilingVal").textContent = `${fmt($("ceiling").value,1)} dB`;
  $("intensityVal").textContent = `${$("intensity").value}%`;
  $("widthVal").textContent = `${fmt($("width").value,2)}x`;
}

["ceiling","intensity","width"].forEach(id=>{
  $(id).addEventListener("input", syncRanges);
});
syncRanges();

function setPresetActive(name){
  document.querySelectorAll(".preset").forEach(b=>{
    b.classList.toggle("active", b.dataset.style === name);
  });
}

function setStyleSummary(text){
  $("styleSummary").textContent = "Style: " + text;
}

/* ===========================
   Presets (one-click)
=========================== */
const PRESETS = {
  worship: {
    label: "Upbeat Worship",
    target: -14,
    ceiling: -1.0,
    intensity: 42,
    width: 1.22,
    hpf:true, mud:true, deharsh:true, air:true,
    glue:true, parallel:true, multiband:true,
    monoBass:true, warmth:true
  },
  poppunch: {
    label: "Pop Punch",
    target: -11,
    ceiling: -1.0,
    intensity: 52,
    width: 1.25,
    hpf:true, mud:true, deharsh:true, air:true,
    glue:true, parallel:true, multiband:true,
    monoBass:true, warmth:true
  },
  rockedge: {
    label: "Rock Edge",
    target: -11,
    ceiling: -1.0,
    intensity: 56,
    width: 1.15,
    hpf:true, mud:true, deharsh:true, air:false,
    glue:true, parallel:false, multiband:true,
    monoBass:true, warmth:false
  },
  lofiwarm: {
    label: "Lo-Fi Warm",
    target: -14,
    ceiling: -1.2,
    intensity: 34,
    width: 1.06,
    hpf:true, mud:true, deharsh:false, air:false,
    glue:true, parallel:true, multiband:false,
    monoBass:true, warmth:true
  },
  clubhot: {
    label: "Club Hot",
    target: -9,
    ceiling: -1.0,
    intensity: 70,
    width: 1.28,
    hpf:true, mud:true, deharsh:true, air:true,
    glue:true, parallel:true, multiband:true,
    monoBass:true, warmth:true
  }
};

function applyPreset(key){
  const p = PRESETS[key];
  if(!p) return;
  state.style = key;
  setPresetActive(key);
  setStyleSummary(p.label);

  $("target").value = String(p.target);
  $("ceiling").value = String(p.ceiling);
  $("intensity").value = String(p.intensity);
  $("width").value = String(p.width);

  $("hpf").checked = p.hpf;
  $("mud").checked = p.mud;
  $("deharsh").checked = p.deharsh;
  $("air").checked = p.air;

  $("glue").checked = p.glue;
  $("parallel").checked = p.parallel;
  $("multiband").checked = p.multiband;

  $("monoBass").checked = p.monoBass;
  $("warmth").checked = p.warmth;

  syncRanges();
}

$("presetBar").addEventListener("click", (e)=>{
  const b = e.target.closest(".preset");
  if(!b) return;
  applyPreset(b.dataset.style);
});

/* default style */
applyPreset("worship");

/* ===========================
   Loading audio
=========================== */
async function ensureCtx(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if(audioCtx.state === "suspended") await audioCtx.resume();
}

async function loadFileToBuffer(file){
  await ensureCtx();
  const arr = await file.arrayBuffer();
  return await audioCtx.decodeAudioData(arr);
}

function bufferToObjectURL(buffer, bitDepth=24){
  const wav = audioBufferToWav(buffer, bitDepth);
  const blob = new Blob([wav], {type:"audio/wav"});
  return URL.createObjectURL(blob);
}

function setMeta(which, stats){
  const metaId = which + "Meta";
  const s = `${stats.ch}ch • ${fmtHz(stats.sr)} • Peak ${fmt(stats.peakDb,1)} dB • LUFS-ish ${fmt(stats.lufsIsh,1)}`;
  $(metaId).textContent = s;
}

function setStatsPill(which, stats){
  const el = $(which + "Stats");
  el.textContent = `Peak: ${fmt(stats.peakDb,1)} dB • RMS: ${fmt(stats.rmsDb,1)} dB • LUFS-ish: ${fmt(stats.lufsIsh,1)}`;
}

/* ===========================
   Original load
=========================== */
$("origFile").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;

  warn("");
  setStatus("Loading Original…", true);

  try{
    state.orig.buffer = await loadFileToBuffer(file);
    state.orig.stats = makeStats(state.orig.buffer);

    // create ws
    if(!state.orig.ws) state.orig.ws = makeWS("#waveOrig");
    if(state.orig.url) URL.revokeObjectURL(state.orig.url);

    // use the uploaded file directly if possible for speed
    state.orig.url = URL.createObjectURL(file);
    await loadIntoWS(state.orig.ws, state.orig.url);

    setMeta("orig", state.orig.stats);
    setStatsPill("orig", state.orig.stats);

    enableOrigControls(true);
    $("autoBtn").disabled = false;
    setStatus("Ready. Pick a style and Auto-Master.", true);

    // If no master yet, disable master controls
    enableMastControls(!!state.mast.buffer);

    // Basic sanity warning
    if(state.orig.stats.peakDb > -0.5){
      warn("Original is already very hot (near 0 dB). Auto-Master will be conservative. If it still distorts, lower Intensity.", false);
    }

  }catch(err){
    console.error(err);
    setStatus("Failed to load Original", false);
    warn("Couldn’t decode that audio. Try WAV/MP3, or re-export the file.", false);
  }
});

/* ===========================
   Reference load
=========================== */
$("refFile").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;

  warn("");
  setStatus("Loading Reference…", true);

  try{
    state.ref.buffer = await loadFileToBuffer(file);
    state.ref.stats = makeStats(state.ref.buffer);

    if(!state.ref.ws) state.ref.ws = makeWS("#waveRef");
    if(state.ref.url) URL.revokeObjectURL(state.ref.url);

    state.ref.url = URL.createObjectURL(file);
    await loadIntoWS(state.ref.ws, state.ref.url);

    setMeta("ref", state.ref.stats);
    setStatsPill("ref", state.ref.stats);
    enableRefControls(true);
    setStatus("Reference loaded (optional).", true);

  }catch(err){
    console.error(err);
    setStatus("Failed to load Reference", false);
    warn("Couldn’t decode that reference file. Try WAV/MP3.", false);
  }
});

/* ===========================
   Player controls (each track)
=========================== */
function hookPlayer(ws, playBtn, pauseBtn, stopBtn){
  $(playBtn).addEventListener("click", ()=>{ stopAll(); ws.play(); });
  $(pauseBtn).addEventListener("click", ()=> ws.pause() );
  $(stopBtn).addEventListener("click", ()=> ws.stop() );
}

hookPlayer(()=>state.orig.ws, "oPlay","oPause","oStop"); // not used

// Hook with direct functions (avoid null errors)
$("oPlay").addEventListener("click", ()=>{ if(state.orig.ws){ stopAll(); state.orig.ws.play(); }});
$("oPause").addEventListener("click", ()=>{ if(state.orig.ws){ state.orig.ws.pause(); }});
$("oStop").addEventListener("click", ()=>{ if(state.orig.ws){ state.orig.ws.stop(); }});

$("mPlay").addEventListener("click", ()=>{ if(state.mast.ws){ stopAll(); state.mast.ws.play(); }});
$("mPause").addEventListener("click", ()=>{ if(state.mast.ws){ state.mast.ws.pause(); }});
$("mStop").addEventListener("click", ()=>{ if(state.mast.ws){ state.mast.ws.stop(); }});

$("rPlay").addEventListener("click", ()=>{ if(state.ref.ws){ stopAll(); state.ref.ws.play(); }});
$("rPause").addEventListener("click", ()=>{ if(state.ref.ws){ state.ref.ws.pause(); }});
$("rStop").addEventListener("click", ()=>{ if(state.ref.ws){ state.ref.ws.stop(); }});

/* ===========================
   Auto-Master
=========================== */
function getSettings(){
  const intensity = parseInt($("intensity").value,10);
  const ceilingDb = parseFloat($("ceiling").value);
  const targetLufsIsh = parseFloat($("target").value);

  const useRef = $("useRef").checked && !!state.ref.buffer;

  // headroom: aim original peaks to about -6 dBFS before processing
  const origPeakDb = state.orig.stats ? state.orig.stats.peakDb : -12;
  const preGainDb = clamp((-6.0 - origPeakDb), -12, 6);

  return {
    intensity,
    ceilingDb,
    targetLufsIsh,

    preGainDb,

    hpfOn: $("hpf").checked,
    mudOn: $("mud").checked,
    deharshOn: $("deharsh").checked,
    airOn: $("air").checked,

    glueOn: $("glue").checked,
    parallelOn: $("parallel").checked,
    multiband: $("multiband").checked,

    width: parseFloat($("width").value),
    monoBass: $("monoBass").checked,
    warmthOn: $("warmth").checked,

    useRef
  };
}

$("autoBtn").addEventListener("click", async ()=>{
  if(!state.orig.buffer) return;

  warn("");
  setStatus("Auto-mastering…", true);
  $("autoBtn").disabled = true;
  $("exportBtn").disabled = true;

  try{
    const s = getSettings();

    // render
    let rendered = await renderMaster(state.orig.buffer, s.useRef ? state.ref.buffer : null, s);

    // loudness target (RMS-based) then ceiling normalize
    rendered = hitTargetLufsIsh(rendered, s.targetLufsIsh);

    // Ceiling: ensures no maxed/clipped output
    rendered = normalizeToCeiling(rendered, s.ceilingDb);

    // Store
    state.mast.buffer = rendered;
    state.mast.stats = makeStats(rendered);

    // Create URL
    if(!state.mast.ws) state.mast.ws = makeWS("#waveMast");
    if(state.mast.url) URL.revokeObjectURL(state.mast.url);

    // For export and waveform preview we generate WAV
    const wavUrl = bufferToObjectURL(rendered, 24);
    state.mast.url = wavUrl;

    await loadIntoWS(state.mast.ws, state.mast.url);

    setMeta("mast", state.mast.stats);
    setStatsPill("mast", state.mast.stats);

    enableMastControls(true);

    // Level-match option: adjust MASTERED playback volume to match original RMS (preview only)
    // WaveSurfer setVolume expects 0..1 (rough). We'll map dB to a safe range.
    if($("lvlMatch").checked && state.orig.stats && state.mast.stats){
      const deltaDb = state.orig.stats.rmsDb - state.mast.stats.rmsDb; // how much to turn mastered down/up
      const g = dbToGain(deltaDb);
      state.mast.ws.setVolume(clamp(g, 0.25, 1.0));
      state.orig.ws?.setVolume(1.0);
    } else {
      state.mast.ws.setVolume(1.0);
      state.orig.ws?.setVolume(1.0);
    }

    // Warn if still too hot
    if(state.mast.stats.peakDb > -0.2){
      warn("Master is very hot. If you hear distortion, drop Intensity or use Streaming target (-14).", false);
    } else {
      warn("Master ready. Use Level-match A/B to judge it honestly.", true);
    }

    setStatus("Master ready. Compare + export.", true);
    $("exportBtn").disabled = false;

  }catch(err){
    console.error(err);
    setStatus("Auto-master failed", false);
    warn("Something crashed during rendering. Try a shorter file or MP3/WAV. Mobile browsers can struggle with huge files.", false);
  }finally{
    $("autoBtn").disabled = false;
  }
});

$("lvlMatch").addEventListener("change", ()=>{
  if(!state.orig.ws || !state.mast.ws || !state.orig.stats || !state.mast.stats) return;

  if($("lvlMatch").checked){
    const deltaDb = state.orig.stats.rmsDb - state.mast.stats.rmsDb;
    const g = dbToGain(deltaDb);
    state.mast.ws.setVolume(clamp(g, 0.25, 1.0));
    state.orig.ws.setVolume(1.0);
  }else{
    state.mast.ws.setVolume(1.0);
    state.orig.ws.setVolume(1.0);
  }
});

/* ===========================
   Export
=========================== */
$("exportBtn").addEventListener("click", ()=>{
  if(!state.mast.buffer) return;
  const wav = audioBufferToWav(state.mast.buffer, 24);
  const blob = new Blob([wav], {type:"audio/wav"});
  downloadBlob(blob, "JaseMaster_Master.wav");
});

/* ===========================
   Reset
=========================== */
$("resetBtn").addEventListener("click", ()=>{
  stopAll();
  warn("");
  setStatus("Load an Original", true);

  // revoke urls
  ["orig","mast","ref"].forEach(k=>{
    if(state[k].url) URL.revokeObjectURL(state[k].url);
    state[k].url = null;
  });

  // destroy wavesurfers
  ["orig","mast","ref"].forEach(k=>{
    if(state[k].ws){
      try{ state[k].ws.destroy(); }catch(e){}
      state[k].ws = null;
    }
    state[k].buffer = null;
    state[k].stats = null;
  });

  $("origFile").value = "";
  $("refFile").value = "";
  $("useRef").checked = false;
  $("autoBtn").disabled = true;
  $("exportBtn").disabled = true;
  enableOrigControls(false);
  enableMastControls(false);
  enableRefControls(false);

  $("origMeta").textContent = "No file loaded";
  $("mastMeta").textContent = "Not generated yet";
  $("refMeta").textContent = "Use a pro track vibe to guide width + tonal tilt";

  $("origStats").textContent = "Peak: — • RMS: — • LUFS-ish: —";
  $("mastStats").textContent = "Peak: — • RMS: — • LUFS-ish: —";
  $("refStats").textContent = "Peak: — • RMS: — • LUFS-ish: —";
});
</script>
</body>
</html>
