<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Wu-Tang Master — Modern Analog</title>
  <style>
    :root{
      --yellow:#FFD400;
      --bg:#0d0d0d;
      --panel:#151515;
      --panel2:#1b1b1b;
      --text:#f2f2f2;
      --muted:#a9a9a9;
      --line:rgba(255,255,255,.10);
      --shadowA: 0 18px 45px rgba(0,0,0,.45);
      --shadowB: 0 2px 0 rgba(255,255,255,.03) inset;
      --radius:18px;
      --good:#00ff88;
      --warn:#ffb020;
      --bad:#ff3b3b;
      --chip:#101010;
      --btn:#111;
      --btnText:#f2f2f2;
      --btnBorder: rgba(255,255,255,.12);
    }

    /* Light (Neumorphic off-white + yellow) */
    body[data-theme="light"]{
      --bg:#F5F5F5;
      --panel:#F0F0F0;
      --panel2:#ECECEC;
      --text:#161616;
      --muted:#5f5f5f;
      --line:rgba(0,0,0,.10);
      --shadowA: 18px 18px 36px rgba(0,0,0,.12), -18px -18px 36px rgba(255,255,255,.85);
      --shadowB: 0 1px 0 rgba(255,255,255,.65) inset;
      --chip:#f1f1f1;
      --btn:#f0f0f0;
      --btnText:#141414;
      --btnBorder: rgba(0,0,0,.12);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: var(--bg);
      color: var(--text);
    }

    header{
      position: sticky; top:0; z-index: 10;
      background: color-mix(in srgb, var(--bg) 88%, transparent);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
    }

    .wrap{max-width:1200px;margin:0 auto;padding:14px 16px}
    .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}

    .brand{display:flex;flex-direction:column;gap:2px}
    .brand h1{margin:0;font-size:18px;letter-spacing:.3px}
    .brand p{margin:0;font-size:12px;color:var(--muted);font-weight:700}

    .actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

    .btn{
      appearance:none;
      border:1px solid var(--btnBorder);
      border-radius: 999px;
      padding:10px 14px;
      background: var(--btn);
      color: var(--btnText);
      font-weight: 950;
      cursor:pointer;
      box-shadow: var(--shadowB);
    }
    .btn.yellow{
      background: var(--yellow);
      border-color: color-mix(in srgb, var(--yellow) 70%, #000 30%);
      color:#000;
    }
    .btn:disabled{opacity:.55; cursor:not-allowed}

    .pill{
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--line);
      background: color-mix(in srgb, var(--panel) 85%, transparent);
      font-size:12px;
      font-weight: 950;
      color: var(--good);
      box-shadow: var(--shadowB);
      white-space:nowrap;
    }

    main{padding:16px}
    .grid{
      max-width:1200px;
      margin:0 auto;
      display:grid;
      grid-template-columns: minmax(0,1.2fr) minmax(320px,.8fr);
      gap:16px;
      align-items:start;
    }

    .card{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadowA), var(--shadowB);
      overflow:hidden;
    }

    .hd{
      padding:12px 14px;
      display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
      border-bottom:1px solid var(--line);
      background:
        linear-gradient(90deg, color-mix(in srgb, var(--yellow) 22%, transparent), transparent 55%);
    }
    .hd h2{
      margin:0;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.7px;
      color: color-mix(in srgb, var(--yellow) 85%, var(--text));
    }
    .meta{font-size:12px;color:var(--muted);font-weight:900}

    .bd{padding:12px 14px}

    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .fileline{
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      padding:10px 12px;border-radius:16px;
      border:1px dashed var(--line);
      background: color-mix(in srgb, var(--panel2) 70%, transparent);
      box-shadow: var(--shadowB);
    }
    input[type=file]{max-width:100%}

    .audiobox{
      margin-top:10px;
      padding:10px;
      border-radius:16px;
      border:1px solid var(--line);
      background: var(--panel2);
      box-shadow: var(--shadowB);
    }
    audio{width:100%}

    .toggle{
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      padding:8px 10px;border-radius:16px;
      border:1px solid var(--line);
      background: var(--panel2);
      font-weight:900;font-size:12px;
      box-shadow: var(--shadowB);
    }
    .toggle input{transform:scale(1.15)}

    .section{
      margin-top:12px;
      padding:12px;
      border-radius:18px;
      border:1px solid var(--line);
      background: var(--panel2);
      box-shadow: var(--shadowB);
    }
    .section h3{
      margin:0 0 10px 0;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.6px;
      color: color-mix(in srgb, var(--yellow) 70%, var(--text));
      display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }

    .field{
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      padding:8px 10px;border-radius:16px;
      border:1px solid var(--line);
      background: color-mix(in srgb, var(--panel) 70%, transparent);
      font-weight:950;font-size:12px;
      box-shadow: var(--shadowB);
      margin-bottom:10px;
    }
    .field input[type=range]{width:190px; max-width:55vw}

    select{
      border-radius: 14px;
      border:1px solid var(--line);
      padding:8px 10px;
      font-weight:900;
      background: var(--panel);
      color: var(--text);
      box-shadow: var(--shadowB);
    }

    .q{
      display:inline-grid;place-items:center;
      width:18px;height:18px;border-radius:50%;
      background: var(--yellow); color:#000;
      font-weight:1100;font-size:12px;
      border:1px solid color-mix(in srgb, var(--yellow) 70%, #000 30%);
      cursor:help; user-select:none;
    }
    .q.hidden{display:none}

    .chips{display:flex;gap:10px;flex-wrap:wrap}
    .chip{
      border-radius:999px;
      padding:9px 12px;
      border:1px solid var(--line);
      background: var(--chip);
      color: var(--text);
      font-weight:1000;
      cursor:pointer;
      box-shadow: var(--shadowB);
      font-size:12px;
    }
    .chip.active{
      background: var(--yellow);
      border-color: color-mix(in srgb, var(--yellow) 70%, #000 30%);
      color:#000;
    }

    .small{font-size:12px;color:var(--muted);font-weight:800}

    .kpi{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .kpi span{
      padding:6px 10px;border-radius:999px;
      border:1px solid var(--line);
      background: color-mix(in srgb, var(--panel2) 75%, transparent);
      font-size:12px;
      font-weight:950;
      box-shadow: var(--shadowB);
    }

    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
  </style>
</head>
<body data-theme="light">
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <h1>Wu-Tang Master — Modern Analog</h1>
        <p>Neumorphic • Light/Dark toggle • WAV export • Decode-fail safe mastering</p>
      </div>
      <div class="actions">
        <button class="btn" id="themeBtn">Dark</button>
        <label class="toggle" data-help="Show/hide quick explanations on hover.">
          <input type="checkbox" id="helpToggle" checked> Help
        </label>
        <label class="toggle" data-help="Mute monitoring during realtime render. (Still records the master.)">
          <input type="checkbox" id="monitorMute" checked> Mute Monitor
        </label>
        <span class="pill" id="statusPill">Load a WAV/MP3 to begin</span>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <!-- LEFT: Players -->
    <div>
      <div class="card">
        <div class="hd">
          <h2>Original</h2>
          <div class="meta" id="origMeta">—</div>
        </div>
        <div class="bd">
          <div class="fileline">
            <input type="file" id="fileMain" accept="audio/*">
            <div class="small">Upload your track (WAV/MP3). Master works even if browser can’t decode the WAV.</div>
          </div>

          <div class="audiobox">
            <audio id="audioOrig" controls preload="metadata"></audio>
          </div>

          <div class="kpi" id="origKpi"></div>
        </div>
      </div>

      <div class="card" style="margin-top:16px;">
        <div class="hd">
          <h2>Mastered</h2>
          <div class="meta" id="mastMeta">—</div>
        </div>
        <div class="bd">
          <div class="audiobox">
            <audio id="audioMast" controls preload="metadata"></audio>
          </div>

          <div class="kpi" id="mastKpi"></div>

          <div class="section">
            <h3>
              A/B Compare
              <span class="q" data-help="Pick what you hear. Keeps your ears honest.">?</span>
            </h3>
            <div class="toggle" data-help="Choose which track plays when you hit Play A/B.">
              <label><input type="radio" name="ab" value="orig" checked> Original</label>
              <label><input type="radio" name="ab" value="mast"> Mastered</label>
            </div>

            <div class="row" style="margin-top:10px;">
              <button class="btn" id="playAB" disabled>Play A/B</button>
              <button class="btn" id="stopAB" disabled>Stop</button>
              <label class="toggle" data-help="Matches loudness during A/B so you judge tone, not volume.">
                <input type="checkbox" id="levelMatch" checked> Level Match
              </label>
            </div>

            <div class="small" style="margin-top:8px">
              If it sounds “louder but worse” → lower Intensity or pick Streaming target.
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:16px;">
        <div class="hd">
          <h2>Reference (Optional)</h2>
          <div class="meta" id="refMeta">—</div>
        </div>
        <div class="bd">
          <div class="fileline">
            <input type="file" id="fileRef" accept="audio/*">
            <div class="small">Upload a pro reference track. Used for “Match Tone” (safe nudges).</div>
          </div>

          <div class="audiobox">
            <audio id="audioRef" controls preload="metadata"></audio>
          </div>

          <div class="kpi" id="refKpi"></div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Master controls -->
    <div>
      <div class="card">
        <div class="hd">
          <h2>Master Controls</h2>
          <div class="meta" id="engineMeta">Engine: —</div>
        </div>
        <div class="bd">

          <div class="chips" id="styleBar">
            <button class="chip active" data-style="upbeat" data-help="Clean vocal sparkle + punchy drums (safe).">Upbeat Worship</button>
            <button class="chip" data-style="pop" data-help="Brighter, tighter, radio pop energy.">Pop Punch</button>
            <button class="chip" data-style="rock" data-help="More mid punch, less shiny highs.">Rock Edge</button>
            <button class="chip" data-style="lofi" data-help="Warmer + softer top end.">Lo-Fi Warm</button>
            <button class="chip" data-style="club" data-help="Hotter master (more risk).">Club Hot</button>
          </div>

          <div class="section">
            <h3>Target <span class="q" data-help="Streaming is safest. Club pushes louder.">?</span></h3>
            <div class="field">
              <label>Preset</label>
              <select id="targetPreset" data-help="Streaming aims for safer loudness. Club is louder.">
                <option value="-14">Streaming (safe)</option>
                <option value="-11">Pop / Hot</option>
                <option value="-9">Club (loud)</option>
              </select>
            </div>

            <div class="field">
              <label>Ceiling <span class="q" data-help="Max peak. -1.0 dB is safe for streaming.">?</span></label>
              <input type="range" id="ceiling" min="-2.0" max="0.0" step="0.1" value="-1.0">
              <span id="ceilingVal">-1.0 dB</span>
            </div>

            <div class="field">
              <label>Intensity <span class="q" data-help="How hard it pushes. Too harsh? lower this.">?</span></label>
              <input type="range" id="intensity" min="0" max="100" step="1" value="35">
              <span id="intensityVal">35%</span>
            </div>

            <div class="field">
              <label>Width <span class="q" data-help="Widen highs only. Too much = phasey.">?</span></label>
              <input type="range" id="width" min="1.0" max="1.35" step="0.01" value="1.10">
              <span id="widthVal">1.10×</span>
            </div>
          </div>

          <div class="section">
            <h3>Cleanup + Tone <span class="q" data-help="Small EQ moves = pro sound.">?</span></h3>
            <div class="row" style="gap:10px;align-items:stretch;flex-wrap:wrap">
              <label class="toggle" data-help="Cuts useless sub rumble below ~30Hz."><input type="checkbox" id="hpf" checked> Remove Rumble</label>
              <label class="toggle" data-help="Gently reduces 250–350Hz mud."><input type="checkbox" id="mud" checked> Reduce Mud</label>
              <label class="toggle" data-help="Tames harsh 2–5kHz."><input type="checkbox" id="deharsh" checked> Tame Harsh</label>
              <label class="toggle" data-help="Adds ‘expensive’ sparkle above 10kHz."><input type="checkbox" id="air" checked> Add Air</label>
              <label class="toggle" data-help="Adds gentle harmonic warmth."><input type="checkbox" id="warmth" checked> Warmth</label>
              <label class="toggle" data-help="Forces sub bass to mono (club-safe)."><input type="checkbox" id="monoBass" checked> Mono Bass</label>
              <label class="toggle" data-help="Light compression glue."><input type="checkbox" id="glue" checked> Glue</label>
              <label class="toggle" data-help="Adds weight without squashing transients."><input type="checkbox" id="parallel" checked> Parallel</label>
            </div>
          </div>

          <div class="section">
            <h3>Actions</h3>
            <div class="row">
              <button class="btn yellow" id="autoBtn" disabled data-help="Creates the master using the best engine available.">Auto-Master</button>
              <button class="btn" id="matchToneBtn" disabled data-help="Uses reference to gently nudge EQ/air/mud toggles and intensity.">Match Tone</button>
              <button class="btn" id="exportBtn" disabled data-help="Downloads mastered WAV.">Export WAV</button>
            </div>
            <div class="small" style="margin-top:10px" id="hint">
              Tip: If mastering sounds “maxed” and ugly, lower <b>Intensity</b> or use <b>Streaming</b>.
            </div>
          </div>

        </div>
      </div>
    </div>

  </div>
</main>

<script>
  const $ = (id)=>document.getElementById(id);

  const state = {
    style:"upbeat",
    helpOn:true,
    ctx:null,
    referenceBuffer:null,
    decodedMainBuffer:null,   // if decodeAudioData works
    engine:"—",
    urls:{orig:null,mast:null,ref:null},
    analysis:{orig:null,mast:null,ref:null},
    masteredBlob:null,
    // realtime render
    workletReady:false,
    capturing:false,
    capture:{ch:2,sr:44100, chunksL:[], chunksR:[], frames:0}
  };

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function dbToGain(db){ return Math.pow(10, db/20); }
  function gainToDb(g){ return 20*Math.log10(Math.max(1e-12,g)); }
  function setStatus(msg, kind="ok"){
    const el=$("statusPill");
    el.textContent = msg;
    el.style.color = kind==="ok" ? "var(--good)" : kind==="warn" ? "var(--warn)" : "var(--bad)";
  }
  function fmtTime(sec){
    sec = Math.max(0, Math.floor(sec||0));
    const m=String(Math.floor(sec/60)).padStart(2,'0');
    const s=String(sec%60).padStart(2,'0');
    return `${m}:${s}`;
  }

  function applyHelpMode(on){
    state.helpOn=!!on;
    document.querySelectorAll(".q").forEach(q=>q.classList.toggle("hidden", !state.helpOn));
    document.querySelectorAll("[data-help]").forEach(el=>{
      if(state.helpOn) el.title = el.getAttribute("data-help");
      else el.removeAttribute("title");
    });
  }

  $("helpToggle").addEventListener("change", e=>applyHelpMode(e.target.checked));
  applyHelpMode(true);

  // Theme toggle
  $("themeBtn").addEventListener("click", ()=>{
    const b=document.body;
    const light = b.getAttribute("data-theme")==="light";
    b.setAttribute("data-theme", light ? "dark" : "light");
    $("themeBtn").textContent = light ? "Light" : "Dark";
  });

  // Style chips
  $("styleBar").addEventListener("click",(e)=>{
    const btn=e.target.closest(".chip"); if(!btn) return;
    state.style=btn.dataset.style;
    document.querySelectorAll(".chip").forEach(x=>x.classList.remove("active"));
    btn.classList.add("active");
  });

  function bindRange(id,outId,fmt){
    const r=$(id), o=$(outId);
    const upd=()=>o.textContent=fmt(r.value);
    r.addEventListener("input",upd); upd();
  }
  bindRange("ceiling","ceilingVal",(v)=>`${Number(v).toFixed(1)} dB`);
  bindRange("intensity","intensityVal",(v)=>`${v|0}%`);
  bindRange("width","widthVal",(v)=>`${Number(v).toFixed(2)}×`);

  function ensureCtx(){
    if(!state.ctx) state.ctx = new (window.AudioContext||window.webkitAudioContext)();
    return state.ctx;
  }

  function setAudioUrl(which, url){
    if(state.urls[which]) URL.revokeObjectURL(state.urls[which]);
    state.urls[which]=url;
    if(which==="orig") $("audioOrig").src=url;
    if(which==="mast") $("audioMast").src=url;
    if(which==="ref")  $("audioRef").src=url;
  }

  function analyzeBuffer(buf){
    const ch0=buf.getChannelData(0);
    const ch1=buf.numberOfChannels>1 ? buf.getChannelData(1) : null;
    let peak=0,sumSq=0;
    const n=ch0.length;
    for(let i=0;i<n;i++){
      const v = ch1 ? 0.5*(ch0[i]+ch1[i]) : ch0[i];
      const a=Math.abs(v);
      if(a>peak) peak=a;
      sumSq+=v*v;
    }
    const rms=Math.sqrt(sumSq/n);
    return {
      peak, peakDb:gainToDb(peak),
      rms, rmsDb:gainToDb(rms),
      lufsIsh: gainToDb(rms),
      sr: buf.sampleRate,
      dur: buf.duration,
      ch: buf.numberOfChannels
    };
  }

  function setMeta(which, info){
    const metaId = which==="orig" ? "origMeta" : which==="mast" ? "mastMeta" : "refMeta";
    const kpiId  = which==="orig" ? "origKpi"  : which==="mast" ? "mastKpi"  : "refKpi";
    $(metaId).textContent = info ? `${info.ch}ch • ${Math.round(info.sr/1000)} kHz • ${fmtTime(info.dur)}` : "—";
    $(kpiId).innerHTML = info ? `
      <span>Peak ${info.peakDb.toFixed(1)} dB</span>
      <span>RMS ${info.rmsDb.toFixed(1)} dB</span>
      <span>LUFS-ish ${info.lufsIsh.toFixed(1)}</span>
    ` : "";
  }

  async function decodeFile(file){
    const ctx=ensureCtx();
    if(ctx.state==="suspended"){ try{ await ctx.resume(); }catch(e){} }
    const arr=await file.arrayBuffer();
    return await ctx.decodeAudioData(arr.slice(0));
  }

  // WAV encoding (32-bit float)
  function encodeWav(buffer){
    const numCh=buffer.numberOfChannels;
    const sr=buffer.sampleRate;
    const numFrames=buffer.length;
    const bitDepth=32;
    const blockAlign=numCh*(bitDepth/8);
    const byteRate=sr*blockAlign;
    const dataSize=numFrames*blockAlign;
    const buf=new ArrayBuffer(44+dataSize);
    const view=new DataView(buf);
    let o=0;
    const wstr=s=>{ for(let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); };
    const u32=x=>{ view.setUint32(o,x,true); o+=4; };
    const u16=x=>{ view.setUint16(o,x,true); o+=2; };

    wstr("RIFF"); u32(36+dataSize); wstr("WAVE");
    wstr("fmt "); u32(16);
    u16(3); u16(numCh); // float format
    u32(sr); u32(byteRate);
    u16(blockAlign); u16(bitDepth);
    wstr("data"); u32(dataSize);

    const chans=[];
    for(let c=0;c<numCh;c++) chans.push(buffer.getChannelData(c));
    for(let i=0;i<numFrames;i++){
      for(let c=0;c<numCh;c++){
        view.setFloat32(o, chans[c][i], true); o+=4;
      }
    }
    return new Uint8Array(buf);
  }

  // --- DSP helpers (safe, bounded to avoid “everything maxed”)
  function makeSaturationCurve(amount){
    const n=65536;
    const curve=new Float32Array(n);
    const k=clamp(amount,0.01,2.0)*2.2;
    const norm=Math.tanh(k);
    for(let i=0;i<n;i++){
      const x=(i/(n-1))*2-1;
      curve[i]=Math.tanh(k*x)/norm;
    }
    return curve;
  }

  // offline master (only if decode succeeded)
  async function offlineMaster(input, settings){
    const aIn=analyzeBuffer(input);
    const preTarget=-6.0;
    const preDb=clamp(preTarget - aIn.peakDb, -30, 12);

    const sr=input.sampleRate;
    const len=input.length;
    const ch=input.numberOfChannels;

    const off=new OfflineAudioContext(ch, len, sr);
    const src=off.createBufferSource();
    src.buffer=input;

    const pre=off.createGain(); pre.gain.value=dbToGain(preDb);

    const hpf=off.createBiquadFilter(); hpf.type="highpass"; hpf.frequency.value=30;
    const mud=off.createBiquadFilter(); mud.type="peaking"; mud.frequency.value=300; mud.Q.value=1.0;
    const harsh=off.createBiquadFilter(); harsh.type="peaking"; harsh.frequency.value=3500; harsh.Q.value=1.2;
    const air=off.createBiquadFilter(); air.type="highshelf"; air.frequency.value=12000;

    const glue=off.createDynamicsCompressor();
    glue.threshold.value=-18; glue.knee.value=20; glue.ratio.value=2.2;
    glue.attack.value=0.03; glue.release.value=0.18;

    const hard=off.createDynamicsCompressor();
    hard.threshold.value=-30; hard.knee.value=10; hard.ratio.value=8;
    hard.attack.value=0.01; hard.release.value=0.22;

    const dry=off.createGain(); dry.gain.value=1.0;
    const wet=off.createGain(); wet.gain.value = settings.parallel ? (0.08 + 0.18*settings.intensity) : 0.0;
    const sum=off.createGain();

    const sat=off.createWaveShaper();
    sat.curve = makeSaturationCurve(0.50 + 0.70*settings.intensity);
    sat.oversample="4x";

    // Chain
    src.connect(pre);
    let n=pre;

    if(settings.hpf){ n.connect(hpf); n=hpf; }
    if(settings.mud){ mud.gain.value = -1.3*settings.intensity; n.connect(mud); n=mud; }
    if(settings.deharsh){ harsh.gain.value = -1.1*settings.intensity; n.connect(harsh); n=harsh; }
    if(settings.air){ air.gain.value = 0.9*settings.intensity; n.connect(air); n=air; }
    if(settings.glue){ n.connect(glue); n=glue; }

    n.connect(dry);
    n.connect(hard); hard.connect(wet);
    dry.connect(sum); wet.connect(sum);

    if(settings.warmth){ sum.connect(sat).connect(off.destination); }
    else sum.connect(off.destination);

    src.start(0);
    const rendered=await off.startRendering();

    // Loudness targeting (bounded!)
    const aR=analyzeBuffer(rendered);
    const makeUpDb = clamp((settings.target - aR.rmsDb) * (0.45 + 0.55*settings.intensity), -10, 8);
    const g = dbToGain(makeUpDb);

    // apply makeup
    const out=new AudioBuffer({length:rendered.length, numberOfChannels:rendered.numberOfChannels, sampleRate:rendered.sampleRate});
    for(let c=0;c<out.numberOfChannels;c++){
      const s=rendered.getChannelData(c);
      const d=out.getChannelData(c);
      for(let i=0;i<s.length;i++) d[i]=s[i]*g;
    }

    // simple brickwall by scaling to ceiling if needed
    const aF=analyzeBuffer(out);
    const ceil=dbToGain(settings.ceiling);
    if(aF.peak > ceil){
      const scale = ceil / aF.peak;
      for(let c=0;c<out.numberOfChannels;c++){
        const d=out.getChannelData(c);
        for(let i=0;i<d.length;i++) d[i]*=scale;
      }
    }
    return out;
  }

  function readSettings(){
    const style = state.style;
    const styleMap={
      upbeat:{tweak:1.0},
      pop:{tweak:1.05},
      rock:{tweak:1.0},
      lofi:{tweak:0.9},
      club:{tweak:1.1}
    };
    const target=Number($("targetPreset").value);
    const ceiling=Number($("ceiling").value);
    const intensity=Number($("intensity").value)/100;
    const width=Number($("width").value);
    return {
      style,
      target: clamp(target * styleMap[style].tweak, -14, -9),
      ceiling,
      intensity,
      width,
      hpf:$("hpf").checked,
      mud:$("mud").checked,
      deharsh:$("deharsh").checked,
      air:$("air").checked,
      warmth:$("warmth").checked,
      monoBass:$("monoBass").checked,
      glue:$("glue").checked,
      parallel:$("parallel").checked
    };
  }

  // ---------- Realtime render fallback (decodeAudioData fails) ----------
  async function setupWorklet(){
    if(state.workletReady) return;
    const ctx=ensureCtx();
    if(ctx.state==="suspended"){ try{ await ctx.resume(); }catch(e){} }

    const workletCode = `
      class CaptureProcessor extends AudioWorkletProcessor {
        constructor(){
          super();
          this.active=false;
          this.ch=2;
          this.port.onmessage=(e)=>{
            if(e.data?.type==="start"){
              this.active=true;
              this.ch=e.data.ch||2;
            }
            if(e.data?.type==="stop"){
              this.active=false;
              this.port.postMessage({type:"stopped"});
            }
          };
        }
        process(inputs){
          if(!this.active) return true;
          const input = inputs[0];
          if(!input || !input[0]) return true;

          const ch = Math.min(this.ch, input.length);
          const frames = input[0].length;

          // Copy to transferable buffers
          const out = [];
          for(let c=0;c<ch;c++){
            const buf = new Float32Array(frames);
            buf.set(input[c]);
            out.push(buf);
          }
          // send chunk
          this.port.postMessage({type:"chunk", frames, ch, out}, out.map(x=>x.buffer));
          return true;
        }
      }
      registerProcessor("capture-processor", CaptureProcessor);
    `;
    const blob = new Blob([workletCode], {type:"application/javascript"});
    const url = URL.createObjectURL(blob);
    await ctx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);
    state.workletReady=true;
  }

  async function realtimeMasterFromAudioElement(){
    const audioEl = $("audioOrig");
    const ctx=ensureCtx();
    if(ctx.state==="suspended"){ try{ await ctx.resume(); }catch(e){} }

    await setupWorklet();

    // Build processing graph (bounded so it doesn’t turn into loud garbage)
    const settings=readSettings();

    // kill any old graph by reloading context nodes is messy; instead: create fresh nodes each render
    const src = ctx.createMediaElementSource(audioEl);

    const pre = ctx.createGain();
    pre.gain.value = 1.0;

    const hpf = ctx.createBiquadFilter(); hpf.type="highpass"; hpf.frequency.value=30;
    const mud = ctx.createBiquadFilter(); mud.type="peaking"; mud.frequency.value=300; mud.Q.value=1.0; mud.gain.value = settings.mud ? (-1.3*settings.intensity) : 0;
    const harsh = ctx.createBiquadFilter(); harsh.type="peaking"; harsh.frequency.value=3500; harsh.Q.value=1.2; harsh.gain.value = settings.deharsh ? (-1.1*settings.intensity) : 0;
    const air = ctx.createBiquadFilter(); air.type="highshelf"; air.frequency.value=12000; air.gain.value = settings.air ? (0.9*settings.intensity) : 0;

    const glue = ctx.createDynamicsCompressor();
    glue.threshold.value=-18; glue.knee.value=20; glue.ratio.value = 2.2;
    glue.attack.value=0.03; glue.release.value=0.18;

    const hard = ctx.createDynamicsCompressor();
    hard.threshold.value=-30; hard.knee.value=10; hard.ratio.value=8;
    hard.attack.value=0.01; hard.release.value=0.22;

    const dry = ctx.createGain(); dry.gain.value=1.0;
    const wet = ctx.createGain(); wet.gain.value = settings.parallel ? (0.08 + 0.18*settings.intensity) : 0.0;
    const sum = ctx.createGain();

    const sat = ctx.createWaveShaper();
    sat.curve = makeSaturationCurve(0.50 + 0.70*settings.intensity);
    sat.oversample="4x";

    // final limiter-ish safety (ceiling)
    const post = ctx.createGain();
    post.gain.value = 1.0;

    // monitoring
    const monitor = ctx.createGain();
    monitor.gain.value = $("monitorMute").checked ? 0.0 : 1.0;

    // capture
    const cap = new AudioWorkletNode(ctx, "capture-processor");
    cap.port.onmessage = (e)=>{
      const d=e.data;
      if(d?.type==="chunk"){
        // chunk = [Float32Array,...]
        state.capture.frames += d.frames;
        if(d.out[0]) state.capture.chunksL.push(new Float32Array(d.out[0]));
        if(d.ch>1 && d.out[1]) state.capture.chunksR.push(new Float32Array(d.out[1]));
      }
    };

    // Routing
    src.connect(pre);

    let n=pre;
    if(settings.hpf) n.connect(hpf), n=hpf;
    n.connect(mud); n=mud;
    n.connect(harsh); n=harsh;
    n.connect(air); n=air;

    if(settings.glue) n.connect(glue), n=glue;

    n.connect(dry);
    n.connect(hard); hard.connect(wet);
    dry.connect(sum); wet.connect(sum);

    if(settings.warmth) sum.connect(sat), sat.connect(post);
    else sum.connect(post);

    // Monitor and capture (post FX)
    post.connect(monitor).connect(ctx.destination);
    post.connect(cap);

    // reset capture store
    state.capture = {ch:2, sr: ctx.sampleRate, chunksL:[], chunksR:[], frames:0};

    cap.port.postMessage({type:"start", ch:2});
    state.capturing=true;

    // play once from start
    audioEl.pause();
    audioEl.currentTime=0;

    // Important: user gesture already triggered Auto-Master click
    await audioEl.play();

    setStatus("Realtime render… playing track once (recording master)", "warn");

    await new Promise((resolve)=>{
      audioEl.onended = ()=>resolve();
    });

    cap.port.postMessage({type:"stop"});
    state.capturing=false;

    // disconnect graph (avoid stacking)
    try{ src.disconnect(); }catch(e){}
    [pre,hpf,mud,harsh,air,glue,hard,dry,wet,sum,sat,post,monitor,cap].forEach(x=>{ try{x.disconnect();}catch(e){} });

    // build AudioBuffer from captured chunks
    const frames = state.capture.frames;
    const sr = state.capture.sr;
    const outBuf = new AudioBuffer({length:frames, numberOfChannels:2, sampleRate:sr});
    const L = outBuf.getChannelData(0);
    const R = outBuf.getChannelData(1);

    let o=0;
    for(const chunk of state.capture.chunksL){
      L.set(chunk, o);
      o += chunk.length;
    }
    o=0;
    for(const chunk of state.capture.chunksR){
      R.set(chunk, o);
      o += chunk.length;
    }

    // final ceiling safety (post-scale if needed)
    const a=analyzeBuffer(outBuf);
    const ceil = dbToGain(settings.ceiling);
    if(a.peak > ceil){
      const s = ceil / a.peak;
      for(let i=0;i<L.length;i++){ L[i]*=s; R[i]*=s; }
    }

    return outBuf;
  }

  // ---------- Match Tone (safe) ----------
  function bandRmsDb(arr){
    let sum=0; for(let i=0;i<arr.length;i++) sum+=arr[i]*arr[i];
    const rms=Math.sqrt(sum/arr.length);
    return gainToDb(rms);
  }

  async function bandProfile(buffer){
    const sr=buffer.sampleRate;
    const segSec=Math.min(10, buffer.duration);
    const segLen=Math.max(1, Math.floor(segSec*sr));
    const start=Math.max(0, Math.floor((buffer.length-segLen)*0.5));
    const seg=new AudioBuffer({length:segLen, numberOfChannels:buffer.numberOfChannels, sampleRate:sr});
    for(let c=0;c<seg.numberOfChannels;c++){
      const src=buffer.getChannelData(c);
      const dst=seg.getChannelData(c);
      for(let i=0;i<segLen;i++) dst[i]=src[start+i]||0;
    }

    const off=new OfflineAudioContext(3, segLen, sr);
    const src=off.createBufferSource(); src.buffer=seg;

    const mono=off.createGain();
    if(seg.numberOfChannels>1){
      const sp=off.createChannelSplitter(2);
      const gL=off.createGain(); gL.gain.value=0.5;
      const gR=off.createGain(); gR.gain.value=0.5;
      src.connect(sp);
      sp.connect(gL,0); sp.connect(gR,1);
      gL.connect(mono); gR.connect(mono);
    } else src.connect(mono);

    const low=off.createBiquadFilter(); low.type="lowpass"; low.frequency.value=200;
    const mid=off.createBiquadFilter(); mid.type="bandpass"; mid.frequency.value=1000; mid.Q.value=0.8;
    const high=off.createBiquadFilter(); high.type="highpass"; high.frequency.value=6000;

    const merge=off.createChannelMerger(3);
    mono.connect(low); low.connect(merge,0,0);
    mono.connect(mid); mid.connect(merge,0,1);
    mono.connect(high); high.connect(merge,0,2);

    merge.connect(off.destination);
    src.start(0);
    const r=await off.startRendering();
    return {
      lowDb: bandRmsDb(r.getChannelData(0)),
      midDb: bandRmsDb(r.getChannelData(1)),
      highDb: bandRmsDb(r.getChannelData(2)),
      totalDb: (bandRmsDb(r.getChannelData(0))+bandRmsDb(r.getChannelData(1))+bandRmsDb(r.getChannelData(2)))/3
    };
  }

  $("matchToneBtn").addEventListener("click", async ()=>{
    if(!state.decodedMainBuffer || !state.referenceBuffer){
      setStatus("Match Tone needs decoded audio + reference.", "warn");
      return;
    }
    try{
      setStatus("Matching tone…", "warn");
      const t=await bandProfile(state.decodedMainBuffer);
      const r=await bandProfile(state.referenceBuffer);

      const lowD=r.lowDb - t.lowDb;
      const midD=r.midDb - t.midDb;
      const highD=r.highDb - t.highDb;

      if(highD > 1.0) $("air").checked=true;
      if(highD < -1.0) $("deharsh").checked=true;
      if(midD < -0.8) $("mud").checked=true;
      if(lowD < -1.0) $("hpf").checked=true;

      let intensity=Number($("intensity").value);
      intensity += clamp((r.totalDb - t.totalDb)*3.0, -10, 6);
      intensity = clamp(intensity, 10, 60);
      $("intensity").value=intensity;
      $("intensityVal").textContent=`${intensity|0}%`;

      setStatus("Tone matched ✅", "ok");
    }catch(e){
      console.error(e);
      setStatus("Match Tone failed.", "bad");
    }
  });

  // ---------- Load main ----------
  $("fileMain").addEventListener("change", async (e)=>{
    const file=e.target.files?.[0];
    if(!file) return;

    // always playable via <audio>
    const url = URL.createObjectURL(file);
    setAudioUrl("orig", url);

    $("autoBtn").disabled=false;
    $("exportBtn").disabled=true;
    $("playAB").disabled=true;
    $("stopAB").disabled=true;

    state.masteredBlob=null;
    $("audioMast").removeAttribute("src");
    $("audioMast").load();
    setMeta("mast", null);

    // attempt decode for offline mastering + metrics
    try{
      setStatus("Decoding for offline master…", "warn");
      const buf=await decodeFile(file);
      state.decodedMainBuffer=buf;
      const a=analyzeBuffer(buf);
      state.analysis.orig=a;
      setMeta("orig",a);
      state.engine="Offline (fast)";
      $("engineMeta").textContent=`Engine: ${state.engine}`;
      $("matchToneBtn").disabled = !state.referenceBuffer;
      setStatus("Ready. Auto-Master available.", "ok");
    }catch(err){
      console.warn("decodeAudioData failed, switching to realtime render:", err);
      state.decodedMainBuffer=null;
      state.analysis.orig=null;
      setMeta("orig", null);
      state.engine="Realtime Render (decode-fail safe)";
      $("engineMeta").textContent=`Engine: ${state.engine}`;
      $("matchToneBtn").disabled = true;
      setStatus("Decode failed. Master will run in realtime (plays once).", "warn");
    }
  });

  // ---------- Load reference ----------
  $("fileRef").addEventListener("change", async (e)=>{
    const file=e.target.files?.[0];
    if(!file) return;
    const url=URL.createObjectURL(file);
    setAudioUrl("ref", url);

    try{
      const buf=await decodeFile(file);
      state.referenceBuffer=buf;
      const a=analyzeBuffer(buf);
      state.analysis.ref=a;
      setMeta("ref", a);
      $("matchToneBtn").disabled = !state.decodedMainBuffer;
      setStatus("Reference ready", "ok");
    }catch(e2){
      console.warn(e2);
      state.referenceBuffer=null;
      setMeta("ref", null);
      $("matchToneBtn").disabled=true;
      setStatus("Reference decode failed (still playable).", "warn");
    }
  });

  // ---------- Auto-master ----------
  $("autoBtn").addEventListener("click", async ()=>{
    const audioEl=$("audioOrig");
    if(!audioEl.src){
      setStatus("Load a track first.", "warn");
      return;
    }
    const settings=readSettings();

    try{
      $("autoBtn").disabled=true;
      $("exportBtn").disabled=true;
      setStatus("Mastering…", "warn");

      let outBuf=null;

      if(state.decodedMainBuffer){
        outBuf = await offlineMaster(state.decodedMainBuffer, settings);
      } else {
        // realtime fallback
        outBuf = await realtimeMasterFromAudioElement();
      }

      // export + set mastered player
      const wav = encodeWav(outBuf);
      const blob = new Blob([wav], {type:"audio/wav"});
      state.masteredBlob=blob;

      const url = URL.createObjectURL(blob);
      setAudioUrl("mast", url);

      const a=analyzeBuffer(outBuf);
      state.analysis.mast=a;
      setMeta("mast", a);

      $("exportBtn").disabled=false;
      $("playAB").disabled=false;
      $("stopAB").disabled=false;

      setStatus("Master ready ✅", "ok");
    }catch(e){
      console.error(e);
      setStatus("Master failed. Lower intensity + try again.", "bad");
    }finally{
      $("autoBtn").disabled=false;
    }
  });

  // ---------- Export ----------
  $("exportBtn").addEventListener("click", ()=>{
    if(!state.masteredBlob){
      setStatus("No master to export.", "warn");
      return;
    }
    const a=document.createElement("a");
    a.href=URL.createObjectURL(state.masteredBlob);
    a.download = `WuTangMaster_${state.style}.wav`;
    a.click();
    setStatus("Exported WAV ✅", "ok");
  });

  // ---------- A/B ----------
  const audioOrig=$("audioOrig");
  const audioMast=$("audioMast");

  function currentAB(){
    const mode=document.querySelector('input[name="ab"]:checked')?.value || "orig";
    return mode==="mast" ? audioMast : audioOrig;
  }
  function otherAB(){
    const mode=document.querySelector('input[name="ab"]:checked')?.value || "orig";
    return mode==="mast" ? audioOrig : audioMast;
  }

  function applyLevelMatch(){
    if(!$("levelMatch").checked) { audioOrig.volume=1; audioMast.volume=1; return; }
    const o=state.analysis.orig, m=state.analysis.mast;
    if(!o || !m) { audioOrig.volume=1; audioMast.volume=1; return; }
    const diffDb = o.rmsDb - m.rmsDb;
    const mastVol = clamp(dbToGain(diffDb), 0.2, 1.0);
    audioOrig.volume=1.0;
    audioMast.volume=mastVol;
  }

  $("playAB").addEventListener("click", async ()=>{
    if(!audioOrig.src || !audioMast.src) return;
    applyLevelMatch();
    const el=currentAB();
    // sync time to whichever is active
    const t=otherAB().currentTime || 0;
    el.currentTime=t;
    await el.play();
    otherAB().pause();
  });

  $("stopAB").addEventListener("click", ()=>{
    audioOrig.pause(); audioMast.pause();
    audioOrig.currentTime=0; audioMast.currentTime=0;
  });

  // Initial
  setStatus("Load a WAV/MP3 to begin", "ok");
</script>
</body>
</html>

