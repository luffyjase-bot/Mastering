<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wu-Tang Master — Auto Mastering (Original / Mastered / Reference)</title>

  <!-- WaveSurfer (waveforms) -->
  <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.js"></script>

  <!-- Essentia.js (client-side analysis). Docs show CDN use via jsDelivr/unpkg. -->
  <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia-wasm.web.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia.js-core.umd.js"></script>

  <style>
    :root{
      --bg:#fff;
      --text:#0b0b0b;
      --muted:#6b6b6b;
      --card:#ffffff;
      --line:#e9e9e9;
      --yellow:#ffd400;         /* Wu-Tang */
      --yellow2:#ffea70;
      --shadow: 0 14px 40px rgba(0,0,0,.08);
      --radius:16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1100px 700px at 20% -10%, var(--yellow2), transparent 55%),
                  radial-gradient(1000px 700px at 95% 10%, #f3f3f3, transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      padding:14px;
    }
    .wrap{max-width:1100px;margin:0 auto;}
    .topbar{
      display:flex; gap:12px; align-items:center; justify-content:space-between;
      padding:14px 14px;
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: rgba(255,255,255,.85);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .brand{
      display:flex; align-items:center; gap:10px; min-width: 210px;
    }
    .logo{
      width:40px;height:40px;border-radius:12px;
      background: linear-gradient(135deg, var(--yellow), #ffb800);
      box-shadow: 0 10px 22px rgba(255,212,0,.35);
      display:grid;place-items:center;
      font-weight:900;
    }
    .brand h1{margin:0;font-size:16px;line-height:1.1}
    .brand small{display:block;color:var(--muted);font-size:12px;margin-top:2px}
    .btn{
      border:1px solid #111;
      background:#111;
      color:#fff;
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      transition:.15s transform, .15s opacity;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); opacity:.92}
    .btn.secondary{
      background:#fff;color:#111;border-color:#111;
    }
    .btn.yellow{
      background: var(--yellow);
      border-color: #111;
      color:#111;
    }
    .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
      .topbar{flex-wrap:wrap}
    }
    .card{
      border:1px solid var(--line);
      background: rgba(255,255,255,.92);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .cardHeader h2{margin:0;font-size:14px}
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      color:#111;
      display:inline-flex; gap:8px; align-items:center;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:#bbb;
    }
    .dot.on{background:#19c37d}
    .cardBody{padding:14px}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    .row > *{flex: 1}
    .row.tight > *{flex: 0 0 auto}
    label{font-size:12px;color:var(--muted)}
    input[type="file"], input[type="text"], select{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#fff;
      color:#111;
      outline:none;
    }
    input[type="range"]{width:140px}
    .mini{
      font-size:12px;color:var(--muted);
    }
    .waveWrap{
      padding:12px;
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
    }
    .waveTitle{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom:8px;
      font-size:12px;
      color:var(--muted);
    }
    .wave{height:84px;}
    .transport{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      margin-top:10px;
    }
    .transport .btn{padding:8px 10px;border-radius:10px;font-size:12px}
    .statGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 540px){
      .statGrid{grid-template-columns: 1fr;}
      input[type="range"]{width:100%}
    }
    .stat{
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      padding:10px 12px;
    }
    .stat b{display:block;font-size:12px}
    .stat span{font-size:12px;color:var(--muted)}
    .controlsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 980px){
      .controlsGrid{grid-template-columns: 1fr;}
    }
    .controlBox{
      border:1px solid var(--line);
      border-radius:14px;
      background:#fff;
      padding:12px;
    }
    .controlBox h3{margin:0 0 10px 0;font-size:12px;text-transform:uppercase;letter-spacing:.08em;color:#111}
    .controlRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 0;
      border-top:1px dashed #efefef;
    }
    .controlRow:first-of-type{border-top:none;padding-top:0}
    .controlRow .left{display:flex; gap:10px; align-items:center}
    .toggle{
      display:inline-flex; gap:8px; align-items:center;
      font-size:12px;color:var(--muted);
      user-select:none;
    }
    .toggle input{transform: scale(1.1)}
    .danger{
      color:#b00020;
      font-weight:700;
    }
    .hint{
      font-size:12px;
      color: var(--muted);
      line-height:1.4;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px;
      border:1px solid var(--line);
      background:#fff;
      border-radius:8px;
      padding:2px 6px;
      color:#111;
    }
  </style>
</head>

<body>
<div class="wrap">

  <div class="topbar">
    <div class="brand">
      <div class="logo">W</div>
      <div>
        <h1>Wu-Tang Master</h1>
        <small>Auto mastering • Original vs Mastered • Reference matching (safe)</small>
      </div>
    </div>

    <div class="row tight" style="gap:10px">
      <button class="btn secondary" id="resetBtn">Reset</button>
      <button class="btn yellow" id="autoBtn" disabled>Auto-Master</button>
      <button class="btn" id="exportBtn" disabled>Export WAV</button>
    </div>
  </div>

  <div class="grid">

    <!-- LEFT: Players -->
    <div class="card">
      <div class="cardHeader">
        <h2>Players</h2>
        <div class="pill">
          <span class="dot" id="readyDot"></span>
          <span id="status">Load an original track</span>
        </div>
      </div>

      <div class="cardBody">

        <div class="controlsGrid">

          <div class="controlBox">
            <h3>Original</h3>
            <label>Upload original mix (WAV/MP3 ok)</label>
            <input type="file" id="origFile" accept="audio/*" />
            <div class="hint" style="margin-top:8px">
              Tip: For best results, export your mix peaking around <span class="kbd">-6 dBFS to -3 dBFS</span>.
            </div>
          </div>

          <div class="controlBox">
            <h3>Reference</h3>
            <label>Upload reference track (optional)</label>
            <input type="file" id="refFile" accept="audio/*" />
            <div style="height:10px"></div>
            <label>…or paste a reference URL (CORS must allow it)</label>
            <input type="text" id="refUrl" placeholder="https://example.com/reference.wav" />
            <div class="row tight" style="margin-top:10px">
              <button class="btn secondary" id="loadRefUrlBtn">Load URL</button>
              <span class="mini">If it fails: download the file and upload instead.</span>
            </div>
          </div>

        </div>

        <div style="height:12px"></div>

        <div class="waveWrap">
          <div class="waveTitle">
            <div><b>Original</b> <span id="origInfo" class="mini">—</span></div>
            <div class="mini">peaks + waveform</div>
          </div>
          <div id="waveOrig" class="wave"></div>
          <div class="transport">
            <button class="btn secondary" id="playOrig" disabled>Play</button>
            <button class="btn secondary" id="pauseAll" disabled>Pause</button>
            <button class="btn secondary" id="stopAll" disabled>Stop</button>
            <span class="mini">A/B: <span class="kbd">Original</span> ↔ <span class="kbd">Mastered</span></span>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="waveWrap">
          <div class="waveTitle">
            <div><b>Mastered</b> <span id="mastInfo" class="mini">—</span></div>
            <div class="mini">generated after Auto-Master</div>
          </div>
          <div id="waveMast" class="wave"></div>
          <div class="transport">
            <button class="btn yellow" id="playMast" disabled>Play</button>
            <button class="btn secondary" id="abToggle" disabled>Toggle A/B</button>
            <label class="toggle"><input type="checkbox" id="levelMatch" checked /> Level-match A/B</label>
          </div>
          <div class="hint" style="margin-top:8px">
            If your mastered version sounds “instantly louder + nasty”, it’s not mastering — it’s bullying. This tool keeps it sane.
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="waveWrap">
          <div class="waveTitle">
            <div><b>Reference</b> <span id="refInfo" class="mini">—</span></div>
            <div class="mini">optional</div>
          </div>
          <div id="waveRef" class="wave"></div>
          <div class="transport">
            <button class="btn secondary" id="playRef" disabled>Play</button>
          </div>
        </div>

        <div class="statGrid">
          <div class="stat"><b>Original</b><span id="origStats">—</span></div>
          <div class="stat"><b>Mastered</b><span id="mastStats">—</span></div>
          <div class="stat"><b>Reference</b><span id="refStats">—</span></div>
        </div>

      </div>
    </div>

    <!-- RIGHT: Master Controls -->
    <div class="card">
      <div class="cardHeader">
        <h2>Auto-Master Controls</h2>
        <div class="pill">
          <span class="mini">Safe by default • tweak if you want</span>
        </div>
      </div>

      <div class="cardBody">

        <div class="controlBox">
          <h3>Auto Style</h3>
          <div class="controlRow">
            <div class="left">
              <label for="styleSel" style="margin:0">Style preset</label>
            </div>
            <select id="styleSel">
              <option value="streaming">Streaming Clean (≈ -14 LUFS feel)</option>
              <option value="pop">Pop Punch (≈ -11 LUFS feel)</option>
              <option value="club">Club Hot (≈ -9 to -10 LUFS feel)</option>
              <option value="worship">Worship Wide (big air + width)</option>
              <option value="rock">Pop Rock Tight (less fizz, firm lows)</option>
            </select>
          </div>

          <div class="controlRow">
            <div class="left">
              <label style="margin:0">Reference matching</label>
            </div>
            <label class="toggle">
              <input type="checkbox" id="refMatch" checked />
              Use reference (if loaded)
            </label>
          </div>

          <div class="hint">
            Reference matching here is “safe + musical”: it aligns <b>level</b>, gentle <b>tone</b>, and <b>width</b> without wrecking your mix.
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="controlBox">
          <h3>Foundation</h3>
          <div class="controlRow">
            <div class="left"><label style="margin:0">Headroom target (pre-chain peak)</label></div>
            <div class="row tight" style="gap:10px">
              <span class="mini"><span id="headroomVal">-4.5</span> dBFS</span>
              <input type="range" id="headroom" min="-8" max="-2" step="0.1" value="-4.5">
            </div>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Ceiling (post limiter)</label></div>
            <div class="row tight" style="gap:10px">
              <span class="mini"><span id="ceilingVal">-1.0</span> dB</span>
              <input type="range" id="ceiling" min="-3" max="0" step="0.1" value="-1.0">
            </div>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Intensity (how hard it pushes)</label></div>
            <div class="row tight" style="gap:10px">
              <span class="mini"><span id="intensityVal">35</span>%</span>
              <input type="range" id="intensity" min="0" max="100" step="1" value="35">
            </div>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Oversampling (anti-alias for clipping)</label></div>
            <div class="row tight" style="gap:10px">
              <select id="oversample">
                <option value="none">none</option>
                <option value="2x" selected>2x</option>
                <option value="4x">4x</option>
              </select>
            </div>
          </div>

          <div class="hint">
            True peak limiting isn’t fully available in browser audio, but ceiling + oversampling + soft clip gets you close enough for personal use.
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="controlBox">
          <h3>Cleanup + Polish</h3>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Sub rumble filter (HPF)</label></div>
            <label class="toggle"><input type="checkbox" id="hpfOn" checked /> 30 Hz</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Cut mud (250 Hz)</label></div>
            <label class="toggle"><input type="checkbox" id="mudOn" checked /> gentle</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">De-harsh (3.5 kHz)</label></div>
            <label class="toggle"><input type="checkbox" id="deharshOn" checked /> gentle</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Air shelf (12 kHz)</label></div>
            <label class="toggle"><input type="checkbox" id="airOn" checked /> pop shine</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Tape warmth (saturation)</label></div>
            <label class="toggle"><input type="checkbox" id="warmOn" checked /> subtle</label>
          </div>

        </div>

        <div style="height:12px"></div>

        <div class="controlBox">
          <h3>Dynamics + Width</h3>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Glue compression (serial)</label></div>
            <label class="toggle"><input type="checkbox" id="glueOn" checked /> 1–2 dB each</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Multiband control</label></div>
            <label class="toggle"><input type="checkbox" id="mbOn" checked /> light</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Parallel compression (NY)</label></div>
            <label class="toggle"><input type="checkbox" id="parOn" checked /> blend</label>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Stereo width</label></div>
            <div class="row tight" style="gap:10px">
              <span class="mini"><span id="widthVal">1.15</span>x</span>
              <input type="range" id="width" min="1" max="1.6" step="0.01" value="1.15">
            </div>
          </div>

          <div class="controlRow">
            <div class="left"><label style="margin:0">Mono bass (below 120 Hz)</label></div>
            <label class="toggle"><input type="checkbox" id="monoBass" checked /> on</label>
          </div>

        </div>

        <div style="height:12px"></div>

        <div class="controlBox">
          <h3>Export</h3>
          <div class="controlRow">
            <div class="left"><label style="margin:0">Bit depth</label></div>
            <select id="bitDepth">
              <option value="16">16-bit PCM</option>
              <option value="24" selected>24-bit PCM</option>
            </select>
          </div>

          <div class="hint">
            Everything runs on your device. No uploading to servers unless you paste a reference URL.
          </div>
          <div id="warn" class="hint danger" style="margin-top:10px; display:none"></div>
        </div>

      </div>
    </div>

  </div>
</div>

<script>
/* -----------------------------------------------------------
   Wu-Tang Master — single file app
   - 3 waveforms (Original/Mastered/Reference)
   - Auto-master that isn't "volume = good"
   - Level matched A/B
   - Optional Essentia analysis (fallback safe if it fails)
------------------------------------------------------------ */

const $ = (id)=>document.getElementById(id);

let audioCtx = null;

let orig = {
  file:null, url:null, buffer:null, ws:null, audio:null, stats:null
};
let mast = {
  url:null, buffer:null, ws:null, audio:null, stats:null
};
let ref = {
  file:null, url:null, buffer:null, ws:null, audio:null, stats:null
};

let essentia = null;
let essentiaReady = false;

function setStatus(msg, on=false){
  $("status").textContent = msg;
  $("readyDot").classList.toggle("on", on);
}

function showWarn(msg){
  const w = $("warn");
  if(!msg){ w.style.display="none"; w.textContent=""; return; }
  w.style.display="block";
  w.textContent = msg;
}

// ---------- WaveSurfer helpers ----------
function makeWave(containerId){
  return WaveSurfer.create({
    container: "#" + containerId,
    waveColor: "#111",
    progressColor: "#ffd400",
    cursorColor: "#111",
    barWidth: 2,
    barGap: 1,
    height: 84,
    normalize: true,
    responsive: true
  });
}

function wsLoad(ws, url){
  return new Promise((resolve, reject)=>{
    ws.once("ready", resolve);
    ws.once("error", reject);
    ws.load(url);
  });
}

// ---------- Audio helpers ----------
function ensureCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

async function decodeFileToBuffer(file){
  const ctx = ensureCtx();
  const arr = await file.arrayBuffer();
  return await ctx.decodeAudioData(arr.slice(0));
}

function fmtDb(x){
  if(!isFinite(x)) return "—";
  return (x>=0?"+":"") + x.toFixed(1) + " dB";
}
function fmtSec(s){
  if(!isFinite(s)) return "—";
  const m = Math.floor(s/60);
  const r = Math.floor(s%60).toString().padStart(2,"0");
  return `${m}:${r}`;
}

// Peak/RMS quick stats (not LUFS; we approximate for safety)
function analyzeBufferQuick(buffer){
  let peak = 0;
  let sumSq = 0;
  let n = 0;
  for(let ch=0; ch<buffer.numberOfChannels; ch++){
    const data = buffer.getChannelData(ch);
    for(let i=0;i<data.length;i+=2){ // downsample a bit
      const v = data[i];
      const av = Math.abs(v);
      if(av>peak) peak = av;
      sumSq += v*v;
      n++;
    }
  }
  const rms = Math.sqrt(sumSq / Math.max(1,n));
  const peakDb = 20*Math.log10(Math.max(1e-12, peak));
  const rmsDb  = 20*Math.log10(Math.max(1e-12, rms));
  return {
    dur: buffer.duration,
    peakDb, rmsDb,
    sr: buffer.sampleRate,
    ch: buffer.numberOfChannels
  };
}

// Try Essentia EBU loudness if available (fallback to RMS estimate)
async function analyzeBufferEssentia(buffer){
  if(!essentiaReady || !essentia) return null;
  try{
    // Downmix to mono float32 for analysis (faster)
    const len = buffer.length;
    const mono = new Float32Array(len);
    for(let ch=0; ch<buffer.numberOfChannels; ch++){
      const d = buffer.getChannelData(ch);
      for(let i=0;i<len;i+=2) mono[i] += d[i] / buffer.numberOfChannels;
      // note: we only fill every 2nd sample; that's fine for "rough" analysis
    }

    // Essentia expects full array; fill missing samples by simple copy
    for(let i=1;i<len;i+=2) mono[i] = mono[i-1];

    // Many builds expose LoudnessEBUR128; if not, return null
    if(typeof essentia.LoudnessEBUR128 !== "function") return null;

    const res = essentia.LoudnessEBUR128(mono, buffer.sampleRate);
    // Depending on build, keys can vary; we try common ones
    const iLufs = (res.integratedLoudness ?? res.integrated_loudness ?? res.loudnessIntegrated);
    return (typeof iLufs === "number") ? iLufs : null;
  }catch(e){
    return null;
  }
}

// Create an <audio> from blob URL, keep it ready for play/sync
function makeAudio(url){
  const a = new Audio();
  a.src = url;
  a.preload = "auto";
  a.crossOrigin = "anonymous";
  return a;
}

function pauseAll(){
  [orig.audio, mast.audio, ref.audio].forEach(a=>{ if(a){ a.pause(); } });
}
function stopAll(){
  [orig.audio, mast.audio, ref.audio].forEach(a=>{ if(a){ a.pause(); a.currentTime=0; } });
}

// Sync play between original/mastered for A/B
let abState = "orig"; // "orig" or "mast"

function playWhich(which){
  // which: "orig" | "mast" | "ref"
  if(audioCtx && audioCtx.state === "suspended") audioCtx.resume();
  if(which === "ref"){
    if(!ref.audio) return;
    pauseAll();
    ref.audio.play();
    return;
  }
  if(which === "orig"){
    if(!orig.audio) return;
    if(mast.audio && !mast.audio.paused){
      // sync from mastered
      orig.audio.currentTime = mast.audio.currentTime || 0;
    }
    pauseAll();
    orig.audio.play();
    abState = "orig";
    return;
  }
  if(which === "mast"){
    if(!mast.audio) return;
    if(orig.audio && !orig.audio.paused){
      mast.audio.currentTime = orig.audio.currentTime || 0;
    }
    pauseAll();
    mast.audio.play();
    abState = "mast";
    return;
  }
}

function toggleAB(){
  if(!orig.audio || !mast.audio) return;
  const levelMatch = $("levelMatch").checked;

  const from = (abState==="orig") ? orig.audio : mast.audio;
  const to   = (abState==="orig") ? mast.audio : orig.audio;

  const t = from.currentTime || 0;
  to.currentTime = t;

  // Level match: make perceived loudness closer (we use RMS/LUFS if available)
  if(levelMatch && orig.stats && mast.stats){
    const fromDb = (abState==="orig") ? (orig.stats.iLufs ?? orig.stats.rmsDb) : (mast.stats.iLufs ?? mast.stats.rmsDb);
    const toDb   = (abState==="orig") ? (mast.stats.iLufs ?? mast.stats.rmsDb) : (orig.stats.iLufs ?? orig.stats.rmsDb);
    const diffDb = (fromDb - toDb); // if to is louder, reduce it
    // audio.volume is linear 0..1; convert dB
    const gain = Math.pow(10, diffDb/20);
    to.volume = Math.min(1, Math.max(0.05, gain));
    from.volume = 1;
  }else{
    orig.audio.volume = 1;
    mast.audio.volume = 1;
  }

  from.pause();
  to.play();
  abState = (abState==="orig") ? "mast" : "orig";
}

// ---------- Mastering chain (Offline render) ----------
// Build a safe mastering graph on an OfflineAudioContext
function buildMasterChain(ctx, settings){
  // settings:
  // { preGainDb, ceilingDb, intensity, width, monoBass, hpfOn, mudOn, deharshOn, airOn, warmOn, glueOn, mbOn, parOn, oversample }
  const nodes = {};

  // Input gain
  nodes.pre = ctx.createGain();
  nodes.pre.gain.value = Math.pow(10, settings.preGainDb/20);

  // HPF
  nodes.hpf = ctx.createBiquadFilter();
  nodes.hpf.type = "highpass";
  nodes.hpf.frequency.value = settings.hpfOn ? 30 : 5;
  nodes.hpf.Q.value = 0.707;

  // Mud cut
  nodes.mud = ctx.createBiquadFilter();
  nodes.mud.type = "peaking";
  nodes.mud.frequency.value = 250;
  nodes.mud.Q.value = 1.0;
  nodes.mud.gain.value = settings.mudOn ? -1.2 : 0;

  // Deharsh
  nodes.deharsh = ctx.createBiquadFilter();
  nodes.deharsh.type = "peaking";
  nodes.deharsh.frequency.value = 3500;
  nodes.deharsh.Q.value = 1.2;
  nodes.deharsh.gain.value = settings.deharshOn ? -1.0 : 0;

  // Air shelf
  nodes.air = ctx.createBiquadFilter();
  nodes.air.type = "highshelf";
  nodes.air.frequency.value = 12000;
  nodes.air.gain.value = settings.airOn ? 1.6 : 0;

  // Glue compression (serial: two gentle comps)
  nodes.comp1 = ctx.createDynamicsCompressor();
  nodes.comp2 = ctx.createDynamicsCompressor();
  if(settings.glueOn){
    nodes.comp1.threshold.value = -18;
    nodes.comp1.ratio.value = 2.0;
    nodes.comp1.attack.value = 0.03;  // slow-ish
    nodes.comp1.release.value = 0.25;

    nodes.comp2.threshold.value = -14;
    nodes.comp2.ratio.value = 1.8;
    nodes.comp2.attack.value = 0.03;
    nodes.comp2.release.value = 0.22;
  }else{
    // effectively off
    nodes.comp1.threshold.value = 0;
    nodes.comp1.ratio.value = 1;
    nodes.comp2.threshold.value = 0;
    nodes.comp2.ratio.value = 1;
  }

  // Parallel compression (NY)
  nodes.parSend = ctx.createGain();
  nodes.parSend.gain.value = settings.parOn ? 0.55 : 0.0;

  nodes.parComp = ctx.createDynamicsCompressor();
  nodes.parComp.threshold.value = -32;
  nodes.parComp.ratio.value = 6;
  nodes.parComp.attack.value = 0.01;
  nodes.parComp.release.value = 0.18;

  nodes.parReturn = ctx.createGain();
  nodes.parReturn.gain.value = settings.parOn ? (0.35 + 0.45*(settings.intensity/100)) : 0.0;

  nodes.sum = ctx.createGain(); // sums dry+parallel

  // Multiband (light): split lows/mids/highs and compress lows a bit more
  nodes.mbIn = ctx.createGain();
  nodes.mbOut = ctx.createGain();

  nodes.lowLP = ctx.createBiquadFilter(); nodes.lowLP.type="lowpass"; nodes.lowLP.frequency.value = 140;
  nodes.lowComp = ctx.createDynamicsCompressor();
  nodes.lowComp.threshold.value = settings.mbOn ? -22 : 0;
  nodes.lowComp.ratio.value = settings.mbOn ? 2.6 : 1;
  nodes.lowComp.attack.value = 0.03;
  nodes.lowComp.release.value = 0.22;

  nodes.midHP = ctx.createBiquadFilter(); nodes.midHP.type="highpass"; nodes.midHP.frequency.value = 140;
  nodes.midLP = ctx.createBiquadFilter(); nodes.midLP.type="lowpass";  nodes.midLP.frequency.value = 4200;
  nodes.midComp = ctx.createDynamicsCompressor();
  nodes.midComp.threshold.value = settings.mbOn ? -20 : 0;
  nodes.midComp.ratio.value = settings.mbOn ? 2.0 : 1;
  nodes.midComp.attack.value = 0.03;
  nodes.midComp.release.value = 0.22;

  nodes.highHP = ctx.createBiquadFilter(); nodes.highHP.type="highpass"; nodes.highHP.frequency.value = 4200;
  nodes.highComp = ctx.createDynamicsCompressor();
  nodes.highComp.threshold.value = settings.mbOn ? -19 : 0;
  nodes.highComp.ratio.value = settings.mbOn ? 1.6 : 1;
  nodes.highComp.attack.value = 0.03;
  nodes.highComp.release.value = 0.20;

  nodes.mbMix = ctx.createGain();

  // Stereo width + mono bass via Mid/Side
  nodes.split = ctx.createChannelSplitter(2);
  nodes.merge = ctx.createChannelMerger(2);

  nodes.lGain = ctx.createGain(); nodes.rGain = ctx.createGain();
  nodes.lInv  = ctx.createGain(); nodes.lInv.gain.value = -1;

  // Mid = (L+R)/2 ; Side = (L-R)/2
  nodes.mid = ctx.createGain(); nodes.side = ctx.createGain();
  nodes.mid.gain.value = 0.5;
  nodes.side.gain.value = 0.5 * Math.max(1, settings.width);

  // Side HPF for mono bass
  nodes.sideHP = ctx.createBiquadFilter();
  nodes.sideHP.type="highpass";
  nodes.sideHP.frequency.value = (settings.monoBass ? 120 : 20);

  // Reconstruct L = Mid + Side ; R = Mid - Side
  nodes.sideToL = ctx.createGain(); nodes.sideToR = ctx.createGain();
  nodes.sideToL.gain.value = 1;
  nodes.sideToR.gain.value = -1;

  // Warmth (tape-ish saturation)
  nodes.warm = ctx.createWaveShaper();
  nodes.warm.oversample = settings.oversample || "2x";
  nodes.warm.curve = makeSaturationCurve(settings.warmOn ? (0.25 + 0.35*(settings.intensity/100)) : 0.0);

  // Soft clipper before limiter (catches transients)
  nodes.clip = ctx.createWaveShaper();
  nodes.clip.oversample = settings.oversample || "2x";
  nodes.clip.curve = makeSoftClipCurve( settings.intensity/100 );

  // Limiter-ish (compressor pushed hard)
  nodes.lim = ctx.createDynamicsCompressor();
  nodes.lim.threshold.value = -8 - 10*(settings.intensity/100);
  nodes.lim.ratio.value = 16;
  nodes.lim.attack.value = 0.003;
  nodes.lim.release.value = 0.12;

  // Output gain to meet ceiling
  nodes.out = ctx.createGain();
  nodes.out.gain.value = Math.pow(10, settings.ceilingDb/20); // ceilingDb is negative

  // Routing:
  // pre -> hpf -> mud -> deharsh -> air -> comp1 -> comp2 -> (parallel blend) -> multiband -> M/S width/mono-bass -> warmth -> clip -> limiter -> out
  nodes.pre.connect(nodes.hpf);
  nodes.hpf.connect(nodes.mud);
  nodes.mud.connect(nodes.deharsh);
  nodes.deharsh.connect(nodes.air);
  nodes.air.connect(nodes.comp1);
  nodes.comp1.connect(nodes.comp2);

  // Parallel path
  nodes.comp2.connect(nodes.parSend);
  nodes.parSend.connect(nodes.parComp);
  nodes.parComp.connect(nodes.parReturn);

  // Sum dry + parallel
  nodes.comp2.connect(nodes.sum);
  nodes.parReturn.connect(nodes.sum);

  // Multiband
  nodes.sum.connect(nodes.mbIn);

  if(settings.mbOn){
    // low
    nodes.mbIn.connect(nodes.lowLP);
    nodes.lowLP.connect(nodes.lowComp);
    nodes.lowComp.connect(nodes.mbOut);

    // mid
    nodes.mbIn.connect(nodes.midHP);
    nodes.midHP.connect(nodes.midLP);
    nodes.midLP.connect(nodes.midComp);
    nodes.midComp.connect(nodes.mbOut);

    // high
    nodes.mbIn.connect(nodes.highHP);
    nodes.highHP.connect(nodes.highComp);
    nodes.highComp.connect(nodes.mbOut);
  }else{
    nodes.mbIn.connect(nodes.mbOut);
  }

  // Mid/Side width
  nodes.mbOut.connect(nodes.split);

  // L and R to mid
  nodes.split.connect(nodes.lGain, 0);
  nodes.split.connect(nodes.rGain, 1);
  nodes.lGain.connect(nodes.mid);
  nodes.rGain.connect(nodes.mid);

  // L and R to side (L - R)
  nodes.split.connect(nodes.lInv, 0);       // -L
  nodes.split.connect(nodes.side, 0);       // +L
  nodes.split.connect(nodes.side, 1);       // +R
  // side = (L + R)/2 ??? Wait, we need (L - R)/2:
  // We'll do: side = (L) + (-R) then half. So invert R:
  nodes.rGain.gain.value = -1;
  nodes.split.connect(nodes.rGain, 1);
  nodes.rGain.connect(nodes.side);
  nodes.lGain.connect(nodes.side);

  // restore rGain to normal for mid path? mid already connected
  // safer: use separate gains for side inversion
  // (We already used rGain for mid; but it’s also used here. We'll fix by re-creating side inversion properly.)
  // NOTE: we'll patch this below: we won't rely on rGain inversion; we'll do separate inversion nodes.
  // We'll return nodes and do correct MS in the chain builder caller.
  return nodes;
}

function buildMasterChain_FIXED(ctx, settings){
  // We rebuild with clean separate nodes for M/S to avoid shared gain inversion
  const n = {};

  n.pre = ctx.createGain();
  n.pre.gain.value = Math.pow(10, settings.preGainDb/20);

  n.hpf = ctx.createBiquadFilter();
  n.hpf.type = "highpass";
  n.hpf.frequency.value = settings.hpfOn ? 30 : 5;
  n.hpf.Q.value = 0.707;

  n.mud = ctx.createBiquadFilter();
  n.mud.type = "peaking"; n.mud.frequency.value = 250; n.mud.Q.value = 1.0;
  n.mud.gain.value = settings.mudOn ? -1.2 : 0;

  n.deharsh = ctx.createBiquadFilter();
  n.deharsh.type = "peaking"; n.deharsh.frequency.value = 3500; n.deharsh.Q.value = 1.2;
  n.deharsh.gain.value = settings.deharshOn ? -1.0 : 0;

  n.air = ctx.createBiquadFilter();
  n.air.type = "highshelf"; n.air.frequency.value = 12000;
  n.air.gain.value = settings.airOn ? 1.6 : 0;

  n.comp1 = ctx.createDynamicsCompressor();
  n.comp2 = ctx.createDynamicsCompressor();
  if(settings.glueOn){
    n.comp1.threshold.value = -18; n.comp1.ratio.value = 2.0; n.comp1.attack.value = 0.03; n.comp1.release.value = 0.25;
    n.comp2.threshold.value = -14; n.comp2.ratio.value = 1.8; n.comp2.attack.value = 0.03; n.comp2.release.value = 0.22;
  }else{
    n.comp1.threshold.value = 0; n.comp1.ratio.value = 1;
    n.comp2.threshold.value = 0; n.comp2.ratio.value = 1;
  }

  // Parallel comp
  n.parSend = ctx.createGain(); n.parSend.gain.value = settings.parOn ? 0.55 : 0.0;
  n.parComp = ctx.createDynamicsCompressor();
  n.parComp.threshold.value = -32; n.parComp.ratio.value = 6; n.parComp.attack.value = 0.01; n.parComp.release.value = 0.18;
  n.parReturn = ctx.createGain();
  n.parReturn.gain.value = settings.parOn ? (0.35 + 0.45*(settings.intensity/100)) : 0.0;
  n.sum = ctx.createGain();

  // Multiband
  n.mbIn = ctx.createGain();
  n.mbOut = ctx.createGain();

  n.lowLP = ctx.createBiquadFilter(); n.lowLP.type="lowpass"; n.lowLP.frequency.value = 140;
  n.lowComp = ctx.createDynamicsCompressor();
  n.lowComp.threshold.value = settings.mbOn ? -22 : 0;
  n.lowComp.ratio.value = settings.mbOn ? 2.6 : 1;
  n.lowComp.attack.value = 0.03; n.lowComp.release.value = 0.22;

  n.midHP = ctx.createBiquadFilter(); n.midHP.type="highpass"; n.midHP.frequency.value = 140;
  n.midLP = ctx.createBiquadFilter(); n.midLP.type="lowpass";  n.midLP.frequency.value = 4200;
  n.midComp = ctx.createDynamicsCompressor();
  n.midComp.threshold.value = settings.mbOn ? -20 : 0;
  n.midComp.ratio.value = settings.mbOn ? 2.0 : 1;
  n.midComp.attack.value = 0.03; n.midComp.release.value = 0.22;

  n.highHP = ctx.createBiquadFilter(); n.highHP.type="highpass"; n.highHP.frequency.value = 4200;
  n.highComp = ctx.createDynamicsCompressor();
  n.highComp.threshold.value = settings.mbOn ? -19 : 0;
  n.highComp.ratio.value = settings.mbOn ? 1.6 : 1;
  n.highComp.attack.value = 0.03; n.highComp.release.value = 0.20;

  // Mid/Side width + mono bass
  n.split = ctx.createChannelSplitter(2);
  n.merge = ctx.createChannelMerger(2);

  // Mid: (L+R)/2
  n.midL = ctx.createGain(); n.midR = ctx.createGain();
  n.midSum = ctx.createGain(); n.midSum.gain.value = 0.5;

  // Side: (L-R)/2
  n.sideL = ctx.createGain(); n.sideR = ctx.createGain(); n.sideR.gain.value = -1;
  n.sideSum = ctx.createGain(); n.sideSum.gain.value = 0.5 * Math.max(1, settings.width);

  n.sideHP = ctx.createBiquadFilter();
  n.sideHP.type="highpass";
  n.sideHP.frequency.value = (settings.monoBass ? 120 : 20);

  // Reconstruct
  n.sideToL = ctx.createGain(); n.sideToL.gain.value = 1;
  n.sideToR = ctx.createGain(); n.sideToR.gain.value = -1;

  // Warm + clip + limiter
  n.warm = ctx.createWaveShaper();
  n.warm.oversample = settings.oversample || "2x";
  n.warm.curve = makeSaturationCurve(settings.warmOn ? (0.25 + 0.35*(settings.intensity/100)) : 0.0);

  n.clip = ctx.createWaveShaper();
  n.clip.oversample = settings.oversample || "2x";
  n.clip.curve = makeSoftClipCurve(settings.intensity/100);

  n.lim = ctx.createDynamicsCompressor();
  n.lim.threshold.value = -8 - 10*(settings.intensity/100);
  n.lim.ratio.value = 16;
  n.lim.attack.value = 0.003;
  n.lim.release.value = 0.12;

  n.out = ctx.createGain();
  n.out.gain.value = Math.pow(10, settings.ceilingDb/20);

  // ROUTE
  n.pre.connect(n.hpf);
  n.hpf.connect(n.mud);
  n.mud.connect(n.deharsh);
  n.deharsh.connect(n.air);
  n.air.connect(n.comp1);
  n.comp1.connect(n.comp2);

  n.comp2.connect(n.parSend);
  n.parSend.connect(n.parComp);
  n.parComp.connect(n.parReturn);

  n.comp2.connect(n.sum);
  n.parReturn.connect(n.sum);

  n.sum.connect(n.mbIn);

  if(settings.mbOn){
    n.mbIn.connect(n.lowLP); n.lowLP.connect(n.lowComp); n.lowComp.connect(n.mbOut);

    n.mbIn.connect(n.midHP); n.midHP.connect(n.midLP); n.midLP.connect(n.midComp); n.midComp.connect(n.mbOut);

    n.mbIn.connect(n.highHP); n.highHP.connect(n.highComp); n.highComp.connect(n.mbOut);
  }else{
    n.mbIn.connect(n.mbOut);
  }

  // MS
  n.mbOut.connect(n.split);

  // mid sum
  n.split.connect(n.midL, 0);
  n.split.connect(n.midR, 1);
  n.midL.connect(n.midSum);
  n.midR.connect(n.midSum);

  // side sum
  n.split.connect(n.sideL, 0);
  n.split.connect(n.sideR, 1);
  n.sideL.connect(n.sideSum);
  n.sideR.connect(n.sideSum);
  n.sideSum.connect(n.sideHP);

  // L = mid + side
  n.midSum.connect(n.merge, 0, 0);
  n.sideHP.connect(n.sideToL);
  n.sideToL.connect(n.merge, 0, 0);

  // R = mid - side
  n.midSum.connect(n.merge, 0, 1);
  n.sideHP.connect(n.sideToR);
  n.sideToR.connect(n.merge, 0, 1);

  // post MS
  n.merge.connect(n.warm);
  n.warm.connect(n.clip);
  n.clip.connect(n.lim);
  n.lim.connect(n.out);

  return n;
}

function makeSaturationCurve(amount){
  // amount 0..~0.6
  const k = Math.max(0.0001, amount * 20);
  const n = 44100;
  const curve = new Float32Array(n);
  for(let i=0;i<n;i++){
    const x = (i/(n-1))*2-1;
    curve[i] = Math.tanh(k*x) / Math.tanh(k);
  }
  return curve;
}

function makeSoftClipCurve(amount){
  // amount 0..1
  const drive = 1 + amount*4;
  const n = 44100;
  const curve = new Float32Array(n);
  for(let i=0;i<n;i++){
    let x = (i/(n-1))*2-1;
    x *= drive;
    // soft clip
    curve[i] = x / (1 + Math.abs(x));
  }
  return curve;
}

// Render offline mastered buffer
async function renderMaster(buffer, settings){
  const channels = buffer.numberOfChannels;
  const sr = buffer.sampleRate;
  const length = buffer.length;

  const off = new OfflineAudioContext(channels, length, sr);
  const src = off.createBufferSource();
  src.buffer = buffer;

  const chain = buildMasterChain_FIXED(off, settings);

  src.connect(chain.pre);
  chain.out.connect(off.destination);

  src.start(0);
  const rendered = await off.startRendering();
  return rendered;
}

// WAV encoding (16/24-bit)
function audioBufferToWav(buffer, bitDepth=24){
  const numCh = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const numFrames = buffer.length;

  const bytesPerSample = (bitDepth === 24) ? 3 : 2;
  const blockAlign = numCh * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = numFrames * blockAlign;

  const bufferSize = 44 + dataSize;
  const view = new DataView(new ArrayBuffer(bufferSize));

  let offset = 0;
  function writeString(s){
    for(let i=0;i<s.length;i++) view.setUint8(offset++, s.charCodeAt(i));
  }
  function writeUint32(v){ view.setUint32(offset, v, true); offset+=4; }
  function writeUint16(v){ view.setUint16(offset, v, true); offset+=2; }

  writeString("RIFF");
  writeUint32(36 + dataSize);
  writeString("WAVE");

  writeString("fmt ");
  writeUint32(16);
  writeUint16(1);               // PCM
  writeUint16(numCh);
  writeUint32(sampleRate);
  writeUint32(byteRate);
  writeUint16(blockAlign);
  writeUint16(bitDepth);

  writeString("data");
  writeUint32(dataSize);

  // Interleave
  const channels = [];
  for(let ch=0; ch<numCh; ch++) channels.push(buffer.getChannelData(ch));

  for(let i=0;i<numFrames;i++){
    for(let ch=0; ch<numCh; ch++){
      let x = channels[ch][i];
      x = Math.max(-1, Math.min(1, x));

      if(bitDepth === 24){
        // signed 24-bit
        let s = (x < 0 ? x * 0x800000 : x * 0x7FFFFF) | 0;
        view.setUint8(offset++, (s      ) & 0xFF);
        view.setUint8(offset++, (s >>  8) & 0xFF);
        view.setUint8(offset++, (s >> 16) & 0xFF);
      }else{
        // signed 16-bit
        let s = (x < 0 ? x * 0x8000 : x * 0x7FFF) | 0;
        view.setInt16(offset, s, true);
        offset += 2;
      }
    }
  }
  return view.buffer;
}

function downloadBlob(blob, filename){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

// ---------- Auto settings ----------
function getSettingsFromUI(){
  return {
    headroomDb: parseFloat($("headroom").value),
    ceilingDb: parseFloat($("ceiling").value),
    intensity: parseInt($("intensity").value,10),
    width: parseFloat($("width").value),
    monoBass: $("monoBass").checked,
    hpfOn: $("hpfOn").checked,
    mudOn: $("mudOn").checked,
    deharshOn: $("deharshOn").checked,
    airOn: $("airOn").checked,
    warmOn: $("warmOn").checked,
    glueOn: $("glueOn").checked,
    mbOn: $("mbOn").checked,
    parOn: $("parOn").checked,
    oversample: $("oversample").value
  };
}

function applyStylePreset(){
  const style = $("styleSel").value;

  // Default "safe"
  let intensity=35, width=1.15, airOn=true, mudOn=true, deharshOn=true, warmOn=true, glueOn=true, mbOn=true, parOn=true, monoBass=true;
  let headroom=-4.5, ceiling=-1.0;

  if(style==="streaming"){
    intensity=28; width=1.12; airOn=true; warmOn=true; parOn=true; mbOn=true;
    headroom=-5.2; ceiling=-1.0;
  }
  if(style==="pop"){
    intensity=42; width=1.18; airOn=true; warmOn=true;
    headroom=-4.5; ceiling=-1.0;
  }
  if(style==="club"){
    intensity=55; width=1.14; airOn=true; warmOn=true; deharshOn=true;
    headroom=-4.0; ceiling=-1.0;
  }
  if(style==="worship"){
    intensity=40; width=1.28; airOn=true; warmOn=true; parOn=true;
    headroom=-4.8; ceiling=-1.0;
  }
  if(style==="rock"){
    intensity=44; width=1.10; airOn=false; deharshOn=true; mudOn=true; warmOn=true;
    headroom=-4.5; ceiling=-1.0;
  }

  $("intensity").value = intensity;
  $("width").value = width;
  $("airOn").checked = airOn;
  $("mudOn").checked = mudOn;
  $("deharshOn").checked = deharshOn;
  $("warmOn").checked = warmOn;
  $("glueOn").checked = glueOn;
  $("mbOn").checked = mbOn;
  $("parOn").checked = parOn;
  $("monoBass").checked = monoBass;
  $("headroom").value = headroom;
  $("ceiling").value = ceiling;

  syncLabels();
}

function syncLabels(){
  $("headroomVal").textContent = parseFloat($("headroom").value).toFixed(1);
  $("ceilingVal").textContent  = parseFloat($("ceiling").value).toFixed(1);
  $("intensityVal").textContent= parseInt($("intensity").value,10);
  $("widthVal").textContent    = parseFloat($("width").value).toFixed(2);
}

["headroom","ceiling","intensity","width"].forEach(id=>{
  $(id).addEventListener("input", syncLabels);
});
$("styleSel").addEventListener("change", applyStylePreset);

// ---------- Load handlers ----------
async function initEssentia(){
  try{
    // EssentiaWASM is global from essentia-wasm.web.js
    const mod = await EssentiaWASM();
    essentia = new Essentia(mod);
    essentiaReady = true;
  }catch(e){
    essentiaReady = false;
  }
}

function updateStatsUI(){
  $("origStats").textContent = orig.stats ? (
    ` dur ${fmtSec(orig.stats.dur)} • peak ${fmtDb(orig.stats.peakDb)} • rms ${fmtDb(orig.stats.rmsDb)}${(orig.stats.iLufs!=null?` • LUFS ${orig.stats.iLufs.toFixed(1)}`:"")}`
  ) : "—";
  $("mastStats").textContent = mast.stats ? (
    ` dur ${fmtSec(mast.stats.dur)} • peak ${fmtDb(mast.stats.peakDb)} • rms ${fmtDb(mast.stats.rmsDb)}${(mast.stats.iLufs!=null?` • LUFS ${mast.stats.iLufs.toFixed(1)}`:"")}`
  ) : "—";
  $("refStats").textContent = ref.stats ? (
    ` dur ${fmtSec(ref.stats.dur)} • peak ${fmtDb(ref.stats.peakDb)} • rms ${fmtDb(ref.stats.rmsDb)}${(ref.stats.iLufs!=null?` • LUFS ${ref.stats.iLufs.toFixed(1)}`:"")}`
  ) : "—";
}

async function loadOriginalFromFile(file){
  showWarn("");
  setStatus("Loading original…", false);

  orig.file = file;
  orig.url = URL.createObjectURL(file);
  orig.buffer = await decodeFileToBuffer(file);

  // stats
  const quick = analyzeBufferQuick(orig.buffer);
  const iLufs = await analyzeBufferEssentia(orig.buffer);
  orig.stats = {...quick, iLufs};

  $("origInfo").textContent = `${orig.stats.ch}ch • ${orig.stats.sr/1000} kHz`;

  // wave
  if(!orig.ws) orig.ws = makeWave("waveOrig");
  await wsLoad(orig.ws, orig.url);

  // audio
  orig.audio = makeAudio(orig.url);

  $("playOrig").disabled = false;
  $("pauseAll").disabled = false;
  $("stopAll").disabled = false;
  $("autoBtn").disabled = false;

  setStatus("Original loaded. Hit Auto-Master.", true);
  updateStatsUI();
}

async function loadReferenceFromFile(file){
  showWarn("");
  setStatus("Loading reference…", false);

  ref.file = file;
  ref.url = URL.createObjectURL(file);
  ref.buffer = await decodeFileToBuffer(file);

  const quick = analyzeBufferQuick(ref.buffer);
  const iLufs = await analyzeBufferEssentia(ref.buffer);
  ref.stats = {...quick, iLufs};

  $("refInfo").textContent = `${ref.stats.ch}ch • ${ref.stats.sr/1000} kHz`;

  if(!ref.ws) ref.ws = makeWave("waveRef");
  await wsLoad(ref.ws, ref.url);

  ref.audio = makeAudio(ref.url);
  $("playRef").disabled = false;

  setStatus("Reference loaded (optional).", true);
  updateStatsUI();
}

async function loadReferenceFromUrl(url){
  showWarn("");
  setStatus("Fetching reference URL…", false);
  try{
    const res = await fetch(url, {mode:"cors"});
    if(!res.ok) throw new Error("Fetch failed");
    const blob = await res.blob();
    const file = new File([blob], "reference_from_url", {type: blob.type || "audio/mpeg"});
    await loadReferenceFromFile(file);
  }catch(e){
    setStatus("Reference URL failed.", false);
    showWarn("Reference URL blocked (usually CORS). Download the file and upload it instead.");
  }
}

// ---------- Auto-master logic ----------
function computePreGainDbForHeadroom(buffer, targetPeakDb){
  // Find current peak (from stats) and compute gain to bring it to targetPeakDb
  const s = analyzeBufferQuick(buffer);
  const needed = targetPeakDb - s.peakDb; // if peakDb is -2 and target is -5 => needed -3 dB
  // safety: don't boost insanely
  return Math.max(-24, Math.min(12, needed));
}

function pickTargetRmsDbByStyle(style){
  // This is NOT LUFS, but gives a safer loudness feel target
  if(style==="streaming") return -16;
  if(style==="worship")   return -14.5;
  if(style==="pop")       return -13.2;
  if(style==="rock")      return -13.4;
  if(style==="club")      return -12.2;
  return -14.8;
}

function computeGainTowardRms(currentRmsDb, targetRmsDb, maxBoostDb){
  const need = targetRmsDb - currentRmsDb;
  return Math.max(-24, Math.min(maxBoostDb, need));
}

async function autoMaster(){
  if(!orig.buffer) return;
  showWarn("");

  setStatus("Auto-mastering (offline render)…", false);
  $("autoBtn").disabled = true;
  $("exportBtn").disabled = true;

  const style = $("styleSel").value;
  const ui = getSettingsFromUI();
  const useRef = $("refMatch").checked && !!ref.buffer;

  // Step 1: bring peak to safe headroom
  const preGainHeadroomDb = computePreGainDbForHeadroom(orig.buffer, ui.headroomDb);

  // Step 2: gentle push toward RMS target (prevents “too loud” disaster)
  const origRmsDb = orig.stats?.rmsDb ?? analyzeBufferQuick(orig.buffer).rmsDb;
  let targetRms = pickTargetRmsDbByStyle(style);

  // If reference exists, nudge toward ref RMS (but not fully copy it)
  if(useRef && ref.stats){
    const refRms = ref.stats.iLufs != null ? (ref.stats.iLufs + 3) : ref.stats.rmsDb; // rough mapping
    // keep within sane window
    targetRms = clamp(refRms - 1.5, -17.5, -12.0);
  }

  // add some intensity scaling
  const maxBoostDb = 3 + (ui.intensity/100)*6; // 3..9 dB
  const preGainRmsDb = computeGainTowardRms(origRmsDb + preGainHeadroomDb, targetRms, maxBoostDb);

  let preGainDb = preGainHeadroomDb + preGainRmsDb;

  // Absolute guardrails: if it tries to boost too much, warn and cap
  if(preGainDb > 10){
    showWarn("Auto-gain tried to boost too hard. I capped it to keep it clean. If your mix is super quiet, re-export hotter (peak around -6 to -3 dBFS).");
    preGainDb = 10;
  }

  // Slight reference width alignment (safe)
  if(useRef && ref.stats){
    // if ref is stereo, allow a bit more width; if mono, keep tight
    const refStereo = (ref.stats.ch >= 2);
    if(refStereo && ui.width < 1.18 && style!=="rock") $("width").value = String(Math.min(1.30, ui.width + 0.06));
    if(!refStereo) $("width").value = "1.05";
    syncLabels();
  }

  // Render
  const settings = {
    preGainDb,
    ceilingDb: ui.ceilingDb,
    intensity: ui.intensity,
    width: parseFloat($("width").value),
    monoBass: ui.monoBass,
    hpfOn: ui.hpfOn,
    mudOn: ui.mudOn,
    deharshOn: ui.deharshOn,
    airOn: ui.airOn,
    warmOn: ui.warmOn,
    glueOn: ui.glueOn,
    mbOn: ui.mbOn,
    parOn: ui.parOn,
    oversample: ui.oversample
  };

  const rendered = await renderMaster(orig.buffer, settings);
  mast.buffer = rendered;

  // stats
  const quick = analyzeBufferQuick(mast.buffer);
  const iLufs = await analyzeBufferEssentia(mast.buffer);
  mast.stats = {...quick, iLufs};
  $("mastInfo").textContent = `${mast.stats.ch}ch • ${mast.stats.sr/1000} kHz`;

  // Create WAV blob for playback + waveform
  const bd = parseInt($("bitDepth").value,10);
  const wav = audioBufferToWav(mast.buffer, bd);
  const blob = new Blob([wav], {type:"audio/wav"});
  mast.url = URL.createObjectURL(blob);
  mast.audio = makeAudio(mast.url);

  if(!mast.ws) mast.ws = makeWave("waveMast");
  await wsLoad(mast.ws, mast.url);

  $("playMast").disabled = false;
  $("abToggle").disabled = false;
  $("exportBtn").disabled = false;

  setStatus("Master ready. A/B it (level-matched).", true);
  updateStatsUI();

  $("autoBtn").disabled = false;
}

// ---------- UI wiring ----------
$("origFile").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  try{
    await loadOriginalFromFile(f);
  }catch(err){
    setStatus("Failed to load original.", false);
    showWarn("Couldn’t decode that file. Try WAV/MP3 from your phone or desktop export.");
  }
});

$("refFile").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  try{
    await loadReferenceFromFile(f);
  }catch(err){
    setStatus("Failed to load reference.", false);
    showWarn("Couldn’t decode that reference file. Try WAV/MP3.");
  }
});

$("loadRefUrlBtn").addEventListener("click", async ()=>{
  const url = $("refUrl").value.trim();
  if(!url) return;
  await loadReferenceFromUrl(url);
});

$("playOrig").addEventListener("click", ()=>playWhich("orig"));
$("playMast").addEventListener("click", ()=>playWhich("mast"));
$("playRef").addEventListener("click", ()=>playWhich("ref"));
$("pauseAll").addEventListener("click", pauseAll);
$("stopAll").addEventListener("click", stopAll);
$("abToggle").addEventListener("click", toggleAB);

$("autoBtn").addEventListener("click", autoMaster);

$("exportBtn").addEventListener("click", ()=>{
  if(!mast.buffer) return;
  const bd = parseInt($("bitDepth").value,10);
  const wav = audioBufferToWav(mast.buffer, bd);
  downloadBlob(new Blob([wav], {type:"audio/wav"}), "WuTang_Master.wav");
});

$("resetBtn").addEventListener("click", ()=>{
  pauseAll();
  stopAll();
  showWarn("");

  // revoke URLs
  [orig.url, mast.url, ref.url].forEach(u=>{ if(u) URL.revokeObjectURL(u); });

  orig = {file:null, url:null, buffer:null, ws:orig.ws, audio:null, stats:null};
  mast = {url:null, buffer:null, ws:mast.ws, audio:null, stats:null};
  ref  = {file:null, url:null, buffer:null, ws:ref.ws, audio:null, stats:null};

  $("origFile").value = "";
  $("refFile").value = "";
  $("refUrl").value = "";

  $("origInfo").textContent = "—";
  $("mastInfo").textContent = "—";
  $("refInfo").textContent = "—";

  updateStatsUI();

  ["playOrig","playMast","playRef","abToggle","exportBtn","autoBtn","pauseAll","stopAll"].forEach(id=>{
    $(id).disabled = true;
  });

  setStatus("Load an original track", false);
});

// tiny helper
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

// init
syncLabels();
applyStylePreset();
setStatus("Loading analysis engine…", false);
initEssentia().then(()=>{
  if(essentiaReady){
    setStatus("Ready. Load an original track.", false);
  }else{
    setStatus("Ready (analysis limited). Load an original track.", false);
  }
});
</script>
</body>
</html>
