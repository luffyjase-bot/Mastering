<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wu Master — Auto Mastering</title>

  <!-- WaveSurfer (pinned) -->
  <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.js"></script>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --panel2:#fffaf0;
      --line:#e8e8e8;

      --text:#0a0a0a;
      --muted:#4b5563;

      /* Wu-Tang vibes */
      --wu:#ffcc00;      /* bright yellow */
      --wu2:#ffd84d;     /* lighter */
      --ink:#0a0a0a;     /* black */

      --radius:18px;
      --shadow: 0 12px 40px rgba(0,0,0,.10);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0; padding:14px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 15% 0%, rgba(255,204,0,.40), transparent 60%),
        radial-gradient(900px 500px at 85% 15%, rgba(255,204,0,.22), transparent 60%),
        var(--bg);
      display:flex;
      justify-content:center;
    }

    .app{
      width: min(1100px, 100%);
      display:grid;
      grid-template-columns: 1.35fr 1fr 1fr;
      gap:14px;
    }

    .card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      overflow:hidden;
    }

    .hero{ grid-column: 1 / -1; padding:16px; }
    .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:10px 0; flex-wrap:wrap; }

    .brand{
      display:flex; flex-direction:column; gap:4px;
    }
    .brand .title{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      font-weight: 900; letter-spacing: .5px;
      font-size: 16px;
    }
    .badge{
      background: var(--wu);
      color: var(--ink);
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 900;
      letter-spacing: 1px;
      text-transform: uppercase;
      border: 1px solid rgba(0,0,0,.12);
    }
    .subtitle{
      color:var(--muted);
      font-size: 12px;
      font-weight: 600;
    }

    .btnbar{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }

    .btn{
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      color: var(--ink);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: .4px;
      cursor:pointer;
      min-height: 44px;
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      transition: transform .12s ease, box-shadow .12s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 24px rgba(0,0,0,.10); }
    .btn:active{ transform: translateY(0); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; transform:none; }

    .btn.primary{
      background: var(--wu);
      border-color: rgba(0,0,0,.18);
    }
    .btn.ghost{
      background: #fff;
    }
    .btn.danger{
      background:#fff;
      border-color: rgba(255,0,0,.25);
    }

    .file{
      width:100%;
      border: 1px dashed rgba(0,0,0,.22);
      background: #fff;
      border-radius: 16px;
      padding: 12px;
      min-height: 44px;
      font-weight: 700;
    }

    #waveform{
      width:100%;
      height: 120px;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 16px;
      margin: 12px 0;
      overflow:hidden;
    }

    .sectionTitle{
      display:flex; align-items:center; justify-content:space-between;
      margin:0 0 8px 0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      font-weight: 900;
      color: var(--ink);
    }
    .hint{ color: var(--muted); font-weight: 700; font-size: 11px; }

    .select, input[type="range"]{
      min-height: 44px;
    }

    .select{
      padding: 11px 12px;
      border-radius: 14px;
      border:1px solid rgba(0,0,0,.14);
      background:#fff;
      font-weight: 800;
      color: var(--ink);
      width: 100%;
      box-shadow: 0 6px 18px rgba(0,0,0,.05);
    }

    .toggleLine{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      font-size: 12px; color: var(--muted); font-weight: 800;
    }
    .toggle{
      display:flex; gap:8px; align-items:center; user-select:none;
      border:1px solid rgba(0,0,0,.12);
      padding: 10px 12px;
      border-radius: 14px;
      background:#fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.05);
    }
    .toggle input{ width:18px; height:18px; accent-color: var(--wu); }

    .meterGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }
    .meter{
      background:#fff;
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      overflow:hidden;
    }
    .meter header{
      display:flex; justify-content:space-between; align-items:center;
      font-size: 11px; font-weight: 900;
      letter-spacing: .6px;
      color: var(--ink);
      margin-bottom: 8px;
      text-transform: uppercase;
    }
    canvas{ width:100%; height:68px; display:block; }

    .status{
      font-weight: 900;
      color: var(--ink);
      background: rgba(255,204,0,.22);
      border: 1px solid rgba(0,0,0,.12);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
    }

    .bigAuto{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background: linear-gradient(90deg, rgba(255,204,0,.65), rgba(255,255,255,.00));
      border:1px solid rgba(0,0,0,.12);
      border-radius: 18px;
      padding: 12px;
      margin-top: 10px;
    }
    .bigAuto .text{
      display:flex; flex-direction:column; gap:2px;
      min-width: 220px;
    }
    .bigAuto .text b{ font-size: 13px; letter-spacing: .4px; }
    .bigAuto .text small{ font-size: 11px; color: var(--muted); font-weight: 800; }

    .sliderLine{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin: 10px 0;
    }
    .sliderLine label{
      font-size: 12px; color: var(--muted); font-weight: 900;
      letter-spacing: .2px;
    }
    input[type="range"]{
      width: 220px;
      accent-color: var(--wu);
    }

    @media(max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      #waveform{ height: 90px; }
      .meterGrid{ grid-template-columns: 1fr; }
      input[type="range"]{ width: 240px; }
    }
  </style>
</head>

<body>
  <div class="app">

    <div class="card hero">
      <div class="row">
        <div class="brand">
          <div class="title">
            Wu Master <span class="badge">AUTO MASTER</span>
          </div>
          <div class="subtitle">
            Upload → Auto → Export. Built for mobile. (Best in Chrome)
          </div>
        </div>

        <div class="btnbar">
          <span class="status" id="status">Load a track</span>
          <button class="btn ghost" id="playBtn" disabled>Play / Pause</button>
          <button class="btn ghost" id="bypassBtn" disabled>Bypass</button>
          <button class="btn primary" id="autoBtn" disabled>AUTO MASTER</button>
          <button class="btn ghost" id="resetBtn" disabled>Reset</button>
          <button class="btn primary" id="exportBtn" disabled>Export WAV</button>
        </div>
      </div>

      <div class="row">
        <input class="file" type="file" id="fileInput" accept="audio/*" />
      </div>

      <div id="waveform"></div>

      <div class="row">
        <div style="flex:1; min-width:230px;">
          <div class="sectionTitle">Master Target <span class="hint">loudness vibe</span></div>
          <select class="select" id="target">
            <option value="stream">Streaming Clean (-14-ish)</option>
            <option value="hot">Hot Pop / Loud (-11-ish)</option>
            <option value="club">Club Smash (-9-ish)</option>
          </select>
        </div>

        <div style="flex:1; min-width:230px;">
          <div class="sectionTitle">Tone <span class="hint">color</span></div>
          <select class="select" id="tone">
            <option value="neutral">Neutral</option>
            <option value="bright">Bright</option>
            <option value="warm">Warm</option>
          </select>
        </div>

        <div style="flex:1; min-width:230px;">
          <div class="sectionTitle">Export <span class="hint">bit depth</span></div>
          <select class="select" id="bitDepth">
            <option value="24" selected>24-bit (recommended)</option>
            <option value="16">16-bit</option>
          </select>
        </div>
      </div>

      <div class="bigAuto">
        <div class="text">
          <b>Auto Intensity</b>
          <small>Safe → Aggressive (controls comp / clip / brightness)</small>
        </div>
        <div style="flex:1; min-width:260px;">
          <div class="sliderLine">
            <label for="intensity">Intensity</label>
            <input type="range" id="intensity" min="0" max="100" value="55">
          </div>
          <div class="toggleLine">
            <div class="toggle">
              <input type="checkbox" id="levelMatch" checked>
              <label for="levelMatch">Level Match</label>
            </div>
            <div class="toggle">
              <input type="checkbox" id="monoBass" checked>
              <label for="monoBass">Mono Bass</label>
            </div>
            <div class="toggle">
              <input type="checkbox" id="widenAir" checked>
              <label for="widenAir">Widen Highs</label>
            </div>
          </div>
        </div>
      </div>

      <div class="meterGrid">
        <div class="meter">
          <header><span>Post Peak</span><span id="peakRead">-- dBFS</span></header>
          <canvas id="peakCanvas" width="900" height="140"></canvas>
        </div>
        <div class="meter">
          <header><span>RMS (Dry/Wet)</span><span id="rmsRead">-- dB</span></header>
          <canvas id="rmsCanvas" width="900" height="140"></canvas>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="sectionTitle">What it does <span class="hint">automatic chain</span></div>
      <div style="color:var(--muted); font-weight:800; font-size:12px; line-height:1.55;">
        • Gain staging to safe headroom<br>
        • HPF @ 30 Hz (rumble cleanup)<br>
        • Smart EQ: mud cut, harsh control, air shelf<br>
        • Glue compression + parallel weight<br>
        • Saturation (warmth) + soft clipper (transients)<br>
        • Limiter ceiling (true-peak-ish) @ -1.0<br>
        • Optional mono bass + widened highs<br>
      </div>
    </div>

    <div class="card">
      <div class="sectionTitle">Pro tips <span class="hint">best results</span></div>
      <div style="color:var(--muted); font-weight:800; font-size:12px; line-height:1.55;">
        • Feed it a mix that isn’t clipping (no red meters).<br>
        • If vocals get crispy: set Tone → Warm, lower intensity.<br>
        • If it’s dull: Tone → Bright, intensity 60–75.<br>
        • Club target is loud—expect less dynamics.<br>
      </div>
    </div>

  </div>

<script>
/* =========================
   Helpers
========================= */
const ui = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const db = (x)=>20*Math.log10(Math.max(1e-9,x));
const lin = (d)=>Math.pow(10,d/20);

function setStatus(msg){
  ui("status").textContent = msg;
}

function makeSaturationCurve(amount){
  const n=2048, curve=new Float32Array(n);
  const k=amount*18;
  for(let i=0;i<n;i++){
    const x=(i*2/n)-1;
    curve[i]=amount===0?x:Math.tanh(x*(1+k))/Math.tanh(1+k);
  }
  return curve;
}
function makeClipCurve(amount){
  const n=2048, curve=new Float32Array(n);
  const a=1+amount*10;
  for(let i=0;i<n;i++){
    const x=(i*2/n)-1;
    curve[i]=amount===0?x:(Math.atan(a*x)/Math.atan(a));
  }
  return curve;
}

/* =========================
   Audio State
========================= */
let audioCtx = null;
let mediaEl = null;
let mediaSource = null;
let wavesurfer = null;
let audioBuffer = null;
let fileNameBase = "WU_MASTER";

const nodes = {};
let rafId = null;

/* =========================
   WaveSurfer
========================= */
function initWaveSurfer(){
  if(wavesurfer) wavesurfer.destroy();
  wavesurfer = WaveSurfer.create({
    container:"#waveform",
    waveColor:"#0a0a0a",
    progressColor:"#ffcc00",
    cursorColor:"#ffcc00",
    height: uiWidthMobile() ? 90 : 120,
    normalize:true,
    responsive:true,
    backend:"MediaElement"
  });
}
function uiWidthMobile(){
  return matchMedia("(max-width: 980px)").matches;
}

/* =========================
   Analysis (fast + simple)
========================= */
function fftMag(x){
  const N=x.length;
  const re = new Float32Array(N);
  const im = new Float32Array(N);
  re.set(x);
  let j=0;
  for(let i=0;i<N;i++){
    if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; }
    let m=N>>1;
    while(m>=1 && j>=m){ j-=m; m>>=1; }
    j+=m;
  }
  for(let size=2; size<=N; size<<=1){
    const half=size>>1;
    const step=N/size;
    for(let i=0;i<N;i+=size){
      for(let k=0;k<half;k++){
        const ang = -2*Math.PI*k*step/N;
        const wr = Math.cos(ang), wi = Math.sin(ang);
        const a = i+k, b = i+k+half;
        const tr = wr*re[b] - wi*im[b];
        const ti = wr*im[b] + wi*re[b];
        re[b] = re[a]-tr; im[b]=im[a]-ti;
        re[a] = re[a]+tr; im[a]=im[a]+ti;
      }
    }
  }
  const out = new Float32Array(N/2);
  for(let i=0;i<N/2;i++) out[i] = Math.sqrt(re[i]*re[i] + im[i]*im[i]);
  return out;
}

function analyzeBuffer(buf){
  const ch0 = buf.getChannelData(0);
  const ch1 = buf.numberOfChannels>1 ? buf.getChannelData(1) : null;

  let peak=0, sumSq=0;
  for(let i=0;i<ch0.length;i++){
    const a=Math.abs(ch0[i]); if(a>peak) peak=a;
    sumSq += ch0[i]*ch0[i];
    if(ch1){ const b=Math.abs(ch1[i]); if(b>peak) peak=b; sumSq += b*b; }
  }
  const n = ch1 ? ch0.length*2 : ch0.length;
  const rms = Math.sqrt(sumSq/Math.max(1,n));

  // quick spectrum snapshot
  const sr = buf.sampleRate;
  const N = 4096;
  const segment = new Float32Array(N);
  const take = Math.min(ch0.length, sr*8);
  const step = Math.max(1, Math.floor(take/N));
  for(let i=0;i<N;i++){
    const idx = Math.min(ch0.length-1, i*step);
    segment[i] = ch0[idx];
  }
  const mags = fftMag(segment);
  const hzPerBin = sr/N;

  const band = (lo,hi)=>{
    const a=Math.floor(lo/hzPerBin);
    const b=Math.floor(hi/hzPerBin);
    let s=0, c=0;
    for(let i=a;i<=b && i<mags.length;i++){ s+=mags[i]; c++; }
    return s/Math.max(1,c);
  };

  const low = band(30,120);
  const mud = band(200,400);
  const harsh = band(2500,5500);
  const air = band(10000,16000);
  const mid = band(800,2000);

  // stereo correlation proxy
  let corr = 0.6;
  if(ch1){
    let num=0,denA=0,denB=0;
    const limit = Math.min(ch0.length, sr*3);
    for(let i=0;i<limit;i+=64){
      const a=ch0[i], b=ch1[i];
      num += a*b; denA += a*a; denB += b*b;
    }
    corr = num / Math.sqrt(Math.max(1e-9, denA*denB));
  }

  return {
    peakDb: db(peak),
    rmsDb: db(rms),
    low,mud,harsh,air,mid,
    corr
  };
}

/* =========================
   Build Mastering Graph
   (Realtime preview chain)
========================= */
function clearNodes(){
  try{ mediaSource?.disconnect(); }catch{}
  for(const k in nodes){
    try{ nodes[k]?.disconnect?.(); }catch{}
    delete nodes[k];
  }
}

function buildGraph(){
  clearNodes();

  // output
  nodes.master = audioCtx.createGain();
  nodes.master.gain.value = 1;
  nodes.master.connect(audioCtx.destination);

  // dry/wet + AB
  nodes.dryGain = audioCtx.createGain(); nodes.dryGain.gain.value = 0;
  nodes.wetGain = audioCtx.createGain(); nodes.wetGain.gain.value = 1;

  // input gain + cleanup
  nodes.inGain = audioCtx.createGain();
  nodes.hpf = audioCtx.createBiquadFilter(); nodes.hpf.type="highpass"; nodes.hpf.Q.value=0.707;

  // smart EQ (simple but effective)
  nodes.eqMud = audioCtx.createBiquadFilter(); nodes.eqMud.type="peaking"; nodes.eqMud.frequency.value=280; nodes.eqMud.Q.value=1.0;
  nodes.eqHarsh = audioCtx.createBiquadFilter(); nodes.eqHarsh.type="peaking"; nodes.eqHarsh.frequency.value=3800; nodes.eqHarsh.Q.value=1.2;
  nodes.eqAir = audioCtx.createBiquadFilter(); nodes.eqAir.type="highshelf"; nodes.eqAir.frequency.value=12000; nodes.eqAir.Q.value=0.707;
  nodes.eqLow = audioCtx.createBiquadFilter(); nodes.eqLow.type="lowshelf"; nodes.eqLow.frequency.value=90; nodes.eqLow.Q.value=0.707;

  // De-harsh dynamic (bandpass -> comp -> mix)
  nodes.dhBand = audioCtx.createBiquadFilter(); nodes.dhBand.type="bandpass"; nodes.dhBand.frequency.value=3500; nodes.dhBand.Q.value=2.2;
  nodes.dhComp = audioCtx.createDynamicsCompressor();
  nodes.dhComp.threshold.value=-28; nodes.dhComp.knee.value=18; nodes.dhComp.ratio.value=6;
  nodes.dhComp.attack.value=0.003; nodes.dhComp.release.value=0.12;
  nodes.dhMix = audioCtx.createGain(); nodes.dhMix.gain.value = 0.55;

  // Glue comp (slow-ish attack)
  nodes.glue = audioCtx.createDynamicsCompressor();
  nodes.glue.knee.value=18; nodes.glue.attack.value=0.03; nodes.glue.release.value=0.25;

  // Parallel comp (NY)
  nodes.nySend = audioCtx.createGain();
  nodes.nyComp = audioCtx.createDynamicsCompressor();
  nodes.nyComp.threshold.value=-30; nodes.nyComp.knee.value=12; nodes.nyComp.ratio.value=8;
  nodes.nyComp.attack.value=0.01; nodes.nyComp.release.value=0.12;
  nodes.nyReturn = audioCtx.createGain();

  // Mid/Side width (simple)
  nodes.msIn = audioCtx.createGain();
  nodes.msOut = audioCtx.createGain();
  nodes.widthGain = audioCtx.createGain(); nodes.widthGain.gain.value = 1.15;

  const split = audioCtx.createChannelSplitter(2);
  const merge = audioCtx.createChannelMerger(2);
  const Lh = audioCtx.createGain(); Lh.gain.value=0.5;
  const Rh = audioCtx.createGain(); Rh.gain.value=0.5;
  const RhInv = audioCtx.createGain(); RhInv.gain.value=-0.5;
  const M = audioCtx.createGain();
  const S = audioCtx.createGain();
  const Sinv = audioCtx.createGain(); Sinv.gain.value=-1;
  const Lout = audioCtx.createGain();
  const Rout = audioCtx.createGain();

  nodes.sideHPF = audioCtx.createBiquadFilter(); nodes.sideHPF.type="highpass"; nodes.sideHPF.Q.value=0.707;
  nodes.sideHighHP = audioCtx.createBiquadFilter(); nodes.sideHighHP.type="highpass"; nodes.sideHighHP.frequency.value=8000; nodes.sideHighHP.Q.value=0.707;
  nodes.sideHighGain = audioCtx.createGain(); nodes.sideHighGain.gain.value=1;

  nodes.msIn.connect(split);
  split.connect(Lh,0); split.connect(Rh,1); split.connect(RhInv,1);
  Lh.connect(M); Rh.connect(M);
  Lh.connect(S); RhInv.connect(S);

  // side chain: mono bass option + widen highs option
  S.connect(nodes.sideHPF);
  const sideBase = audioCtx.createGain(); sideBase.gain.value=1;
  const sideHighMix = audioCtx.createGain(); sideHighMix.gain.value=1;
  const sideTotal = audioCtx.createGain();

  nodes.sideHPF.connect(sideBase);
  nodes.sideHPF.connect(nodes.sideHighHP);
  nodes.sideHighHP.connect(nodes.sideHighGain);
  nodes.sideHighGain.connect(nodes.widthGain);
  nodes.widthGain.connect(sideHighMix);

  sideBase.connect(sideTotal);
  sideHighMix.connect(sideTotal);

  M.connect(Lout); sideTotal.connect(Lout);
  M.connect(Rout); sideTotal.connect(Sinv); Sinv.connect(Rout);

  Lout.connect(merge,0,0);
  Rout.connect(merge,0,1);
  merge.connect(nodes.msOut);

  // color + safety
  nodes.tape = audioCtx.createWaveShaper(); nodes.tape.oversample="2x";
  nodes.clip = audioCtx.createWaveShaper(); nodes.clip.oversample="4x";
  nodes.limiter = audioCtx.createDynamicsCompressor();
  nodes.limiter.knee.value=0; nodes.limiter.ratio.value=20; nodes.limiter.attack.value=0.002; nodes.limiter.release.value=0.08;

  // analyser
  nodes.anWet = audioCtx.createAnalyser(); nodes.anWet.fftSize=2048;
  nodes.anDry = audioCtx.createAnalyser(); nodes.anDry.fftSize=1024;

  // ROUTING
  mediaSource.connect(nodes.dryGain);
  mediaSource.connect(nodes.inGain);

  nodes.dryGain.connect(nodes.anDry);
  nodes.anDry.connect(nodes.master);

  nodes.inGain.connect(nodes.hpf);
  nodes.hpf.connect(nodes.eqLow);
  nodes.eqLow.connect(nodes.eqMud);
  nodes.eqMud.connect(nodes.eqHarsh);
  nodes.eqHarsh.connect(nodes.eqAir);

  nodes.eqAir.connect(nodes.dhBand);
  nodes.dhBand.connect(nodes.dhComp);
  nodes.dhComp.connect(nodes.dhMix);

  nodes.eqAir.connect(nodes.glue);
  nodes.dhMix.connect(nodes.glue);

  nodes.glue.connect(nodes.nySend);
  nodes.nySend.connect(nodes.nyComp);
  nodes.nyComp.connect(nodes.nyReturn);

  nodes.sum = audioCtx.createGain();
  nodes.glue.connect(nodes.sum);
  nodes.nyReturn.connect(nodes.sum);

  nodes.sum.connect(nodes.msIn);
  nodes.msOut.connect(nodes.tape);
  nodes.tape.connect(nodes.clip);
  nodes.clip.connect(nodes.limiter);

  nodes.limiter.connect(nodes.wetGain);
  nodes.wetGain.connect(nodes.anWet);
  nodes.anWet.connect(nodes.master);

  applyParamsFromAuto(); // apply initial
  startMeters();
}

/* =========================
   Auto Master Parameters
========================= */
let autoParams = null; // computed after analysis

function defaultParams(){
  return {
    // core
    prePeakTargetDb: -4.5,
    hpfHz: 30,
    lowShelfDb: 0.0,
    mudDb: -1.6,
    harshDb: -0.8,
    airDb: 1.2,

    deharshMix: 0.55,

    glueThreshold: -24,
    glueRatio: 2.0,

    nyReturn: 0.16, // parallel amount

    sideHPFHz: 200,
    widenGain: 1.15,
    widenOn: true,

    satAmt: 0.45,
    clipAmt: 0.55,

    ceilingDb: -1.0,

    bypass: false
  };
}

function computeAutoParams(){
  if(!audioBuffer) return defaultParams();
  const a = analyzeBuffer(audioBuffer);

  const target = ui("target").value;
  const tone = ui("tone").value;
  const intensity = Number(ui("intensity").value)/100;
  const monoBass = ui("monoBass").checked;
  const widenAir = ui("widenAir").checked;

  const p = defaultParams();

  // Loudness vibe / punch
  if(target==="stream"){
    p.prePeakTargetDb = -5.0;
    p.glueThreshold = -22;
    p.glueRatio = 1.8;
    p.nyReturn = 0.12 + intensity*0.08;
    p.satAmt = 0.30 + intensity*0.25;
    p.clipAmt = 0.30 + intensity*0.35;
  }else if(target==="hot"){
    p.prePeakTargetDb = -4.0;
    p.glueThreshold = -24 - intensity*2;
    p.glueRatio = 2.1 + intensity*0.6;
    p.nyReturn = 0.16 + intensity*0.12;
    p.satAmt = 0.40 + intensity*0.35;
    p.clipAmt = 0.55 + intensity*0.30;
  }else{ // club
    p.prePeakTargetDb = -3.2;
    p.glueThreshold = -26 - intensity*3;
    p.glueRatio = 2.4 + intensity*0.9;
    p.nyReturn = 0.22 + intensity*0.18;
    p.satAmt = 0.55 + intensity*0.35;
    p.clipAmt = 0.70 + intensity*0.25;
  }

  // spectrum decisions
  const mudRatio = a.mud / Math.max(1e-9, a.mid);
  const harshRatio = a.harsh / Math.max(1e-9, a.mid);
  const airRatio = a.air / Math.max(1e-9, a.mid);
  const lowRatio = a.low / Math.max(1e-9, a.mid);

  // mud/harsh/air scaling with intensity
  p.mudDb = -clamp(0.8 + (mudRatio*2.2) + intensity*1.8, 0.6, 4.2);
  p.harshDb = -clamp(0.4 + (harshRatio*2.0) + intensity*1.6, 0.4, 4.0);

  // "air" if dull; less if already airy
  p.airDb = clamp((1.2 + intensity*1.2) - (airRatio*1.4), 0.0, 3.8);

  // Low shelf: tighten or add weight depending on lowRatio
  if(target==="club"){
    // club wants controlled but present low end
    p.lowShelfDb = clamp(0.8 - (lowRatio*0.9) + intensity*0.3, -1.2, 1.4);
  }else{
    p.lowShelfDb = clamp(0.4 - (lowRatio*0.8), -1.4, 1.2);
  }

  // Tone preset nudges
  if(tone==="bright"){
    p.airDb = clamp(p.airDb + 1.0, 0, 4.5);
    p.harshDb = p.harshDb - 0.3; // more control so brightness isn't painful
  }else if(tone==="warm"){
    p.airDb = clamp(p.airDb - 0.8, 0, 4.5);
    p.mudDb = p.mudDb - 0.2; // less cut
    p.satAmt = clamp(p.satAmt + 0.15, 0, 1);
  }

  // Deharsh mix (dynamic harsh control)
  p.deharshMix = clamp(0.35 + harshRatio*0.35 + intensity*0.25, 0.25, 0.85);

  // Width logic based on correlation
  const corr = a.corr;
  let widen = 1.15;
  if(corr > 0.8) widen = 1.25;          // very mono -> safe widen
  else if(corr < 0.2) widen = 1.08;     // already very wide -> chill
  else widen = 1.18;

  p.widenOn = widenAir;
  p.widenGain = widenAir ? widen : 1.0;

  // Mono bass / side HPF
  p.sideHPFHz = monoBass ? 200 : 5;

  // Ceiling fixed -1.0 dBTP-ish
  p.ceilingDb = -1.0;

  // Gain staging to target peak
  const gainDb = clamp(p.prePeakTargetDb - a.peakDb, -12, 12);
  p.inputGainDb = gainDb;

  return p;
}

function applyParamsFromAuto(){
  if(!audioCtx || !nodes.inGain) return;

  autoParams = computeAutoParams();

  // input gain to hit sweet spot
  nodes.inGain.gain.value = lin(autoParams.inputGainDb ?? 0);

  // cleanup
  nodes.hpf.frequency.value = autoParams.hpfHz;

  // EQ
  nodes.eqLow.gain.value = autoParams.lowShelfDb;
  nodes.eqMud.gain.value = autoParams.mudDb;
  nodes.eqHarsh.gain.value = autoParams.harshDb;
  nodes.eqAir.gain.value = autoParams.airDb;

  // deharsh mix
  nodes.dhMix.gain.value = autoParams.deharshMix;

  // glue
  nodes.glue.threshold.value = autoParams.glueThreshold;
  nodes.glue.ratio.value = autoParams.glueRatio;

  // parallel return
  nodes.nyReturn.gain.value = autoParams.nyReturn;

  // width
  nodes.sideHPF.frequency.value = autoParams.sideHPFHz;
  nodes.widthGain.gain.value = autoParams.widenGain;

  // color
  nodes.tape.curve = makeSaturationCurve(autoParams.satAmt);
  nodes.clip.curve = makeClipCurve(autoParams.clipAmt);

  // limiter ceiling
  nodes.limiter.threshold.value = autoParams.ceilingDb;

  // bypass (preview)
  const bypassed = (autoParams.bypass === true);
  nodes.wetGain.gain.value = bypassed ? 0 : 1;
  nodes.dryGain.gain.value = bypassed ? 1 : 0;
}

/* =========================
   Meters + Level Match
========================= */
function startMeters(){
  if(rafId) cancelAnimationFrame(rafId);

  const peakC = ui("peakCanvas");
  const rmsC = ui("rmsCanvas");
  const pctx = peakC.getContext("2d");
  const rctx = rmsC.getContext("2d");

  const wetTime = new Float32Array(nodes.anWet.fftSize);
  const dryTime = new Float32Array(nodes.anDry.fftSize);

  function drawBar(ctx, label, valueDb, y, h, color){
    const w = ctx.canvas.width;
    ctx.fillStyle = "rgba(0,0,0,0.04)";
    ctx.fillRect(12, y, w-24, h);
    const frac = clamp((valueDb + 60)/60, 0, 1);
    ctx.fillStyle = color;
    ctx.fillRect(12, y, (w-24)*frac, h);
  }

  function loop(){
    // peak
    nodes.anWet.getFloatTimeDomainData(wetTime);
    let peak=0, wetSum=0;
    for(let i=0;i<wetTime.length;i++){
      const v = wetTime[i];
      const a = Math.abs(v); if(a>peak) peak=a;
      wetSum += v*v;
    }
    const peakDb = db(peak);
    const wetRms = Math.sqrt(wetSum / wetTime.length);
    const wetDb = db(wetRms);
    ui("peakRead").textContent = `${peakDb.toFixed(1)} dBFS`;

    // dry rms
    nodes.anDry.getFloatTimeDomainData(dryTime);
    let drySum=0;
    for(let i=0;i<dryTime.length;i++){
      const v = dryTime[i];
      drySum += v*v;
    }
    const dryRms = Math.sqrt(drySum / dryTime.length);
    const dryDb = db(dryRms);
    ui("rmsRead").textContent = `Dry ${dryDb.toFixed(1)} • Wet ${wetDb.toFixed(1)} dB`;

    // level match (so you aren’t fooled by loud)
    if(ui("levelMatch").checked && nodes.wetGain && nodes.dryGain){
      // when wet is active, match wet to dry RMS
      if(nodes.wetGain.gain.value > 0.5){
        const diff = wetDb - dryDb;
        const target = clamp(lin(-diff), 0.6, 1.6);
        nodes.wetGain.gain.value += (target - nodes.wetGain.gain.value)*0.08;
      }
      // when dry is active, match dry to wet RMS
      if(nodes.dryGain.gain.value > 0.5){
        const diff = dryDb - wetDb;
        const target = clamp(lin(-diff), 0.6, 1.6);
        nodes.dryGain.gain.value += (target - nodes.dryGain.gain.value)*0.08;
      }
    }

    // draw peak canvas
    pctx.clearRect(0,0,peakC.width,peakC.height);
    drawBar(pctx, "PEAK", peakDb, 40, 44, peakDb > -1 ? "#ef4444" : (peakDb > -6 ? "#f59e0b" : "#10b981"));
    pctx.fillStyle = "rgba(0,0,0,0.75)";
    pctx.font = "24px system-ui";
    pctx.fillText("PEAK", 12, 28);

    // draw rms canvas
    rctx.clearRect(0,0,rmsC.width,rmsC.height);
    drawBar(rctx, "DRY", dryDb, 28, 32, "rgba(0,0,0,0.35)");
    drawBar(rctx, "WET", wetDb, 78, 32, "#ffcc00");
    rctx.fillStyle = "rgba(0,0,0,0.75)";
    rctx.font = "20px system-ui";
    rctx.fillText("RMS", 12, 22);

    rafId = requestAnimationFrame(loop);
  }
  loop();
}

/* =========================
   Load + Transport
========================= */
function enableControls(on){
  ui("playBtn").disabled = !on;
  ui("bypassBtn").disabled = !on;
  ui("autoBtn").disabled = !on;
  ui("resetBtn").disabled = !on;
  ui("exportBtn").disabled = !on;
}

ui("fileInput").addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if(!file) return;

  fileNameBase = (file.name||"WU_MASTER").replace(/\.[^/.]+$/,"");

  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  // Decode for analysis + offline export
  setStatus("Loading…");
  const arr = await file.arrayBuffer();
  audioBuffer = await audioCtx.decodeAudioData(arr.slice(0));

  // Media element for realtime
  if(!mediaEl){
    mediaEl = new Audio();
    mediaEl.crossOrigin = "anonymous";
    mediaEl.preload = "auto";
  }
  mediaEl.pause();
  mediaEl.currentTime = 0;

  const url = URL.createObjectURL(file);
  mediaEl.src = url;

  initWaveSurfer();
  wavesurfer.load(url);

  // Important: createMediaElementSource only once per Audio element per context
  // so recreate mediaEl if needed
  try{
    if(mediaSource) { try{ mediaSource.disconnect(); }catch{} }
    mediaSource = audioCtx.createMediaElementSource(mediaEl);
  }catch(err){
    console.error(err);
    setStatus("Browser blocked audio. Use Chrome.");
    return;
  }

  buildGraph();
  enableControls(true);
  setStatus("Ready. Hit AUTO MASTER.");
});

ui("playBtn").addEventListener("click", async ()=>{
  if(!mediaEl || !audioCtx) return;
  if(audioCtx.state==="suspended") await audioCtx.resume();

  if(mediaEl.paused){
    await mediaEl.play();
    try{ wavesurfer.play(); }catch{}
    setStatus("Playing…");
  }else{
    mediaEl.pause();
    try{ wavesurfer.pause(); }catch{}
    setStatus("Paused.");
  }
});

ui("bypassBtn").addEventListener("click", ()=>{
  if(!nodes.wetGain || !nodes.dryGain) return;
  const wetOn = nodes.wetGain.gain.value > 0.5;
  if(wetOn){
    nodes.wetGain.gain.value = 0;
    nodes.dryGain.gain.value = 1;
    setStatus("Bypass: ON (dry)");
  }else{
    nodes.wetGain.gain.value = 1;
    nodes.dryGain.gain.value = 0;
    setStatus("Bypass: OFF (master)");
    applyParamsFromAuto(); // restore intended gains
  }
});

ui("autoBtn").addEventListener("click", ()=>{
  if(!audioBuffer) return;
  setStatus("Auto mastering…");
  applyParamsFromAuto();
  setStatus("Auto master ✓ Export when ready.");
});

ui("resetBtn").addEventListener("click", ()=>{
  if(!audioBuffer) return;
  ui("target").value = "stream";
  ui("tone").value = "neutral";
  ui("intensity").value = 55;
  ui("monoBass").checked = true;
  ui("widenAir").checked = true;
  ui("levelMatch").checked = true;
  applyParamsFromAuto();
  setStatus("Reset ✓");
});

["target","tone","intensity","monoBass","widenAir"].forEach(id=>{
  ui(id).addEventListener("change", ()=>{ if(audioBuffer) applyParamsFromAuto(); });
  ui(id).addEventListener("input", ()=>{ if(audioBuffer) applyParamsFromAuto(); });
});

/* =========================
   Offline Export (WAV 16/24)
========================= */
function removeDCOffset(buf){
  const out = new AudioBuffer({ length: buf.length, numberOfChannels: buf.numberOfChannels, sampleRate: buf.sampleRate });
  for(let ch=0; ch<buf.numberOfChannels; ch++){
    const input=buf.getChannelData(ch);
    const data=out.getChannelData(ch);
    let mean=0;
    for(let i=0;i<input.length;i++) mean+=input[i];
    mean/=input.length;
    for(let i=0;i<input.length;i++) data[i]=input[i]-mean;
  }
  return out;
}

function audioBufferToWavBlob(buffer, bitDepth=24){
  const numChannels=buffer.numberOfChannels, sampleRate=buffer.sampleRate, length=buffer.length;
  const interleaved=new Float32Array(length*numChannels);
  const chans=[];
  for(let ch=0;ch<numChannels;ch++) chans.push(buffer.getChannelData(ch));
  for(let i=0;i<length;i++){
    for(let ch=0;ch<numChannels;ch++){
      interleaved[i*numChannels+ch]=chans[ch][i];
    }
  }

  const bytesPerSample = bitDepth===16 ? 2 : 3;
  const blockAlign = numChannels*bytesPerSample;
  const byteRate = sampleRate*blockAlign;
  const dataSize = interleaved.length*bytesPerSample;

  const ab = new ArrayBuffer(44+dataSize);
  const view = new DataView(ab);
  let o=0;
  const ws=(s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o++, s.charCodeAt(i)); };

  ws("RIFF"); view.setUint32(o, 36+dataSize, true); o+=4;
  ws("WAVE");
  ws("fmt "); view.setUint32(o,16,true); o+=4;
  view.setUint16(o,1,true); o+=2;
  view.setUint16(o,numChannels,true); o+=2;
  view.setUint32(o,sampleRate,true); o+=4;
  view.setUint32(o,byteRate,true); o+=4;
  view.setUint16(o,blockAlign,true); o+=2;
  view.setUint16(o,bitDepth,true); o+=2;
  ws("data"); view.setUint32(o,dataSize,true); o+=4;

  if(bitDepth===16){
    for(let i=0;i<interleaved.length;i++){
      const s=clamp(interleaved[i],-1,1);
      view.setInt16(o, s<0 ? s*0x8000 : s*0x7FFF, true);
      o+=2;
    }
  }else{
    for(let i=0;i<interleaved.length;i++){
      const s=clamp(interleaved[i],-1,1);
      let v = s<0 ? Math.floor(s*0x800000) : Math.floor(s*0x7FFFFF);
      view.setUint8(o++, v & 255);
      view.setUint8(o++, (v>>8)&255);
      view.setUint8(o++, (v>>16)&255);
    }
  }

  return new Blob([ab], {type:"audio/wav"});
}

ui("exportBtn").addEventListener("click", async ()=>{
  if(!audioBuffer) return;

  setStatus("Exporting…");
  const bitDepth = Number(ui("bitDepth").value);
  const cleaned = removeDCOffset(audioBuffer);

  // Compute params once, then apply in offline render
  const p = computeAutoParams();

  const offCtx = new OfflineAudioContext(cleaned.numberOfChannels, cleaned.length, cleaned.sampleRate);
  const src = offCtx.createBufferSource();
  src.buffer = cleaned;

  const inGain = offCtx.createGain();
  inGain.gain.value = lin(p.inputGainDb ?? 0);

  const hpf = offCtx.createBiquadFilter(); hpf.type="highpass"; hpf.Q.value=0.707; hpf.frequency.value = p.hpfHz;

  const eqLow = offCtx.createBiquadFilter(); eqLow.type="lowshelf"; eqLow.frequency.value=90; eqLow.gain.value=p.lowShelfDb;
  const eqMud = offCtx.createBiquadFilter(); eqMud.type="peaking"; eqMud.frequency.value=280; eqMud.Q.value=1.0; eqMud.gain.value=p.mudDb;
  const eqHarsh = offCtx.createBiquadFilter(); eqHarsh.type="peaking"; eqHarsh.frequency.value=3800; eqHarsh.Q.value=1.2; eqHarsh.gain.value=p.harshDb;
  const eqAir = offCtx.createBiquadFilter(); eqAir.type="highshelf"; eqAir.frequency.value=12000; eqAir.Q.value=0.707; eqAir.gain.value=p.airDb;

  const dhBand = offCtx.createBiquadFilter(); dhBand.type="bandpass"; dhBand.frequency.value=3500; dhBand.Q.value=2.2;
  const dhComp = offCtx.createDynamicsCompressor();
  dhComp.threshold.value=-28; dhComp.knee.value=18; dhComp.ratio.value=6; dhComp.attack.value=0.003; dhComp.release.value=0.12;
  const dhMix = offCtx.createGain(); dhMix.gain.value = p.deharshMix;

  const glue = offCtx.createDynamicsCompressor();
  glue.threshold.value=p.glueThreshold; glue.knee.value=18; glue.ratio.value=p.glueRatio;
  glue.attack.value=0.03; glue.release.value=0.25;

  const nySend = offCtx.createGain(); nySend.gain.value=1;
  const nyComp = offCtx.createDynamicsCompressor();
  nyComp.threshold.value=-30; nyComp.knee.value=12; nyComp.ratio.value=8; nyComp.attack.value=0.01; nyComp.release.value=0.12;
  const nyReturn = offCtx.createGain(); nyReturn.gain.value = p.nyReturn;

  const sum = offCtx.createGain();

  // We keep offline MS width simple: widen highs by a touch (not full M/S math here to keep export stable)
  // If you want true offline M/S, I can extend this with channel split/merge as well.
  const tape = offCtx.createWaveShaper(); tape.oversample="2x"; tape.curve = makeSaturationCurve(p.satAmt);
  const clip = offCtx.createWaveShaper(); clip.oversample="4x"; clip.curve = makeClipCurve(p.clipAmt);

  const limiter = offCtx.createDynamicsCompressor();
  limiter.threshold.value=p.ceilingDb; limiter.knee.value=0; limiter.ratio.value=20;
  limiter.attack.value=0.002; limiter.release.value=0.08;

  // route
  src.connect(inGain);
  inGain.connect(hpf);
  hpf.connect(eqLow); eqLow.connect(eqMud); eqMud.connect(eqHarsh); eqHarsh.connect(eqAir);

  eqAir.connect(dhBand); dhBand.connect(dhComp); dhComp.connect(dhMix);

  eqAir.connect(glue);
  dhMix.connect(glue);

  glue.connect(sum);

  glue.connect(nySend);
  nySend.connect(nyComp);
  nyComp.connect(nyReturn);
  nyReturn.connect(sum);

  sum.connect(tape);
  tape.connect(clip);
  clip.connect(limiter);
  limiter.connect(offCtx.destination);

  src.start(0);
  const rendered = await offCtx.startRendering();

  const blob = audioBufferToWavBlob(rendered, bitDepth);
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `${fileNameBase}_WU_MASTER_${bitDepth}bit.wav`;
  a.click();

  setStatus("Export complete ✅");
});
</script>
</body>
</html>

